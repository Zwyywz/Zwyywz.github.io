<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【YOLOv5】原理详解</title>
      <link href="/2021/06/21/yolo-yuan-li-xiang-jie/"/>
      <url>/2021/06/21/yolo-yuan-li-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="【YOLOv5】原理详解"><a href="#【YOLOv5】原理详解" class="headerlink" title="【YOLOv5】原理详解"></a>【YOLOv5】原理详解</h1><h2 id="一、目标检测的性能指标"><a href="#一、目标检测的性能指标" class="headerlink" title="一、目标检测的性能指标"></a>一、目标检测的性能指标</h2><h3 id="1-1、混淆矩阵（confusion-matrix）"><a href="#1-1、混淆矩阵（confusion-matrix）" class="headerlink" title="1.1、混淆矩阵（confusion matrix）"></a>1.1、混淆矩阵（confusion matrix）</h3><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624133726978.png"></p><ul><li>精度Precision(查准率)：评估预测准不准</li><li>召回率Recall（查全率）： 评估找的准不准</li></ul><h3 id="1-2-IoU-Intersection-over-Union"><a href="#1-2-IoU-Intersection-over-Union" class="headerlink" title="1.2 IoU(Intersection over Union)"></a>1.2 IoU(Intersection over Union)</h3><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624134253965.png"></p><p>==IoU=1 : 意味着预测边界框和地面真实边界框完全重叠。==<br>也可以为IoU设置阈值，以确定目标检测是否有效。假设将Lou设置为0.5，在这种情况下。<br>如果LOU &gt;=0.5，则将目标检测分类为正样本(TP)。<br>如果LOU &lt; 0.5，则为错误检测，并将其归类为负样本(FP)。<br>当图像中存在检测框且模型未能检测到目标时，它被认为是错误的无目标检测(FN)。<br>正确的无目标检测(TN)：TN是我们没有预测到物体的图像的每一部分且不含有目标。</p><h3 id="1-3-AP-and-mAP"><a href="#1-3-AP-and-mAP" class="headerlink" title="1.3 AP and mAP"></a>1.3 AP and mAP</h3><ul><li>AP衡量的是学习出来的模型在每个类别上的好坏</li><li>mAP衡量的是学出的模型在所有类别上的好坏。mAP就是取所有类别上AP的平均值</li></ul><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624135045653.png"></p><h2 id="二、YOLOv5项目代码解析"><a href="#二、YOLOv5项目代码解析" class="headerlink" title="二、YOLOv5项目代码解析"></a>二、YOLOv5项目代码解析</h2><h3 id="2-1-激活函数（Activations-py）"><a href="#2-1-激活函数（Activations-py）" class="headerlink" title="2.1 激活函数（Activations.py）"></a>2.1 激活函数（Activations.py）</h3><p>激活函数相当于是一个激活单元：</p><ul><li>激活函数使神经网络具有非线性。它决定感知机是否激发。</li><li>激活函数的这种非线性赋予了深度网络学习复杂函数的能力。</li></ul><p>常见的激活函数如下：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624154414778.png"></p><p>但是YOLOv5中所用到的激活函数稍微复杂一点：</p><p>==1、Swish函数==<br>$$<br>f(x) = x · sigmoid(x)<br>$$<br>YOLOv5中swish函数的实现：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#utils\activations.py</span><span class="token keyword">class</span> <span class="token class-name">SiLU</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># export-friendly version of nn.SiLU()</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> torch<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624155031806.png"></p><p>==2、Mish函数==<br>$$<br>f(x) = x·tanh(softplus(x)) = x·tanh(ln(1+e^x))<br>$$<br>YOLOv5中Mish函数的实现：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#utils\activations.py</span><span class="token keyword">class</span> <span class="token class-name">Mish</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> F<span class="token punctuation">.</span>softplus<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>tanh<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624155337025.png"></p><p>Mish函数和Swish函数的一阶导数和二阶导数图像如下，以及大范围内的函数图像：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624155535494.png"></p><p>==3、Hardswish函数==<br>$$<br>Hardswish(x) = \begin{cases}<br>0,              \quad x\leq -3\<br>x,              \quad x&gt;+3\<br>x·(x+3)/6 ,     \quad otherwise \<br>\end{cases}<br>\tag{1}<br>$$</p><p>YOLOv5中Hardswish函数的实现：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#utils\activations.py</span><span class="token keyword">class</span> <span class="token class-name">Hardswish</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># export-friendly version of nn.Hardswish()</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># return x * F.hardsigmoid(x)  # for torchscript and CoreML</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> F<span class="token punctuation">.</span>hardtanh<span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">6</span><span class="token punctuation">.</span>  <span class="token comment" spellcheck="true"># for torchscript, CoreML and ONNX</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210624185837375.png"></p><h3 id="2-2-模型代码解析-common-py"><a href="#2-2-模型代码解析-common-py" class="headerlink" title="2.2 模型代码解析(common.py )"></a>2.2 模型代码解析(common.py )</h3><p>YOLOv5整个网络结构如图所示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/yolov5model.png"></p><p><strong>蓝色框（Conv</strong>）代表：卷积（conv）+ Batch Normalization (BN) + 激活函数（Hardwish）</p><p><strong>立体蓝色框（Conv）</strong>代表：卷积步长为2，其他与蓝色框一致</p><p>YOLOv5-python代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 为same卷积或same池化自动扩充</span><span class="token keyword">def</span> <span class="token function">autopad</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> p<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># kernel, padding</span>    <span class="token comment" spellcheck="true"># Pad to 'same'</span>    <span class="token keyword">if</span> p <span class="token keyword">is</span> None<span class="token punctuation">:</span>        p <span class="token operator">=</span> k <span class="token operator">//</span> <span class="token number">2</span> <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>k<span class="token punctuation">,</span> int<span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">[</span>x <span class="token operator">//</span> <span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> k<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># auto-pad</span>    <span class="token keyword">return</span> p<span class="token comment" spellcheck="true"># 深度可分离卷积</span><span class="token keyword">def</span> <span class="token function">DWConv</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> act<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># k=1是卷积核kenel，s=1是步长stride</span>    <span class="token comment" spellcheck="true"># Depthwise convolution</span>    <span class="token keyword">return</span> Conv<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> k<span class="token punctuation">,</span> s<span class="token punctuation">,</span> g<span class="token operator">=</span>math<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">)</span><span class="token punctuation">,</span> act<span class="token operator">=</span>act<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># math.gcd() 返回的是最大公约数</span><span class="token keyword">class</span> <span class="token class-name">Conv</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Standard convolution 标准卷积：conv+BN+hardswish</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> p<span class="token operator">=</span>None<span class="token punctuation">,</span> g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> act<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># ch_in, ch_out, kernel, stride, padding, groups</span>        super<span class="token punctuation">(</span>Conv<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> k<span class="token punctuation">,</span> s<span class="token punctuation">,</span> autopad<span class="token punctuation">(</span>k<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>g<span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bn <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span>c2<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>act <span class="token operator">=</span> nn<span class="token punctuation">.</span>Hardswish<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> act <span class="token keyword">else</span> nn<span class="token punctuation">.</span>Identity<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 网络的执行顺序是根据 forward 函数来决定的</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>act<span class="token punctuation">(</span>self<span class="token punctuation">.</span>bn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">fuseforward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>act<span class="token punctuation">(</span>self<span class="token punctuation">.</span>conv<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>深黄色框（Bottlenack True）</strong>代表: 输入X经过两次蓝色框（Conv）后与输入X相加的和</p><p><strong>浅黄色框（Bottlenack False）</strong>代表：输入X经过两次蓝色框（Conv）后的输出</p><p>YOLOv5-python代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Bottleneck</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Standard bottleneck</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> shortcut<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># ch_in, ch_out, shortcut, groups, expansion</span>        super<span class="token punctuation">(</span>Bottleneck<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        c_ <span class="token operator">=</span> int<span class="token punctuation">(</span>c2 <span class="token operator">*</span> e<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># hidden channels</span>        self<span class="token punctuation">.</span>cv1 <span class="token operator">=</span> Conv<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cv2 <span class="token operator">=</span> Conv<span class="token punctuation">(</span>c_<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> g<span class="token operator">=</span>g<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add <span class="token operator">=</span> shortcut <span class="token operator">and</span> c1 <span class="token operator">==</span> c2    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 根据self.add的值确定是否有shortcut</span>        <span class="token keyword">return</span> x <span class="token operator">+</span> self<span class="token punctuation">.</span>cv2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>add <span class="token keyword">else</span> self<span class="token punctuation">.</span>cv2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>深黄色框（BCSPn）</strong>代表: CSP( Cross Stage partial Network)跨阶段局部网络, 输入X 一路经过蓝色框（Conv）和n个深黄色框（Bottlenack True）串联，再接一个紫色框（典型的卷积）；另一路接一个紫色框（典型的卷积）；将两路输出做拼接。再将输出经过Batch Normalization (BN) +激活函数（Leaky Relu）+蓝色框（Conv）得到最终输出。</p><p><strong>浅黄色框（BCSPn）</strong>代表:  n个Bottlenack False</p><p>YOLOv5-python代码如下:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">BottleneckCSP</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># CSP Bottleneck https://github.com/WongKinYiu/CrossStagePartialNetworks</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> shortcut<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># ch_in, ch_out, number, shortcut, groups, expansion</span>        super<span class="token punctuation">(</span>BottleneckCSP<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        c_ <span class="token operator">=</span> int<span class="token punctuation">(</span>c2 <span class="token operator">*</span> e<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># hidden channels</span>        self<span class="token punctuation">.</span>cv1 <span class="token operator">=</span> Conv<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cv2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cv3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>c_<span class="token punctuation">,</span> c_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cv4 <span class="token operator">=</span> Conv<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> c_<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bn <span class="token operator">=</span> nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> c_<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># applied to cat(cv2, cv3)</span>        self<span class="token punctuation">.</span>act <span class="token operator">=</span> nn<span class="token punctuation">.</span>LeakyReLU<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># *操作符可以把一个list拆开成一个个独立的元素</span>        self<span class="token punctuation">.</span>m <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">[</span>Bottleneck<span class="token punctuation">(</span>c_<span class="token punctuation">,</span> c_<span class="token punctuation">,</span> shortcut<span class="token punctuation">,</span> g<span class="token punctuation">,</span> e<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        y1 <span class="token operator">=</span> self<span class="token punctuation">.</span>cv3<span class="token punctuation">(</span>self<span class="token punctuation">.</span>m<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        y2 <span class="token operator">=</span> self<span class="token punctuation">.</span>cv2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cv4<span class="token punctuation">(</span>self<span class="token punctuation">.</span>act<span class="token punctuation">(</span>self<span class="token punctuation">.</span>bn<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>y1<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>绿色网格框（Focus）</strong>代表：先做分片（slice）再做拼接（Connect）,在经过蓝色框(Conv)。</p><p>==Focus作用：==把数据切分为4份,每份数据都是相当于2倍下采样得到的,然后在 channe维度进行拼接,最后进行卷积操作。如下图所示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210625110610159.png"></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#假设出入Tensor如下：</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#则经过Focus输出的Tensor如下：</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>以 Yolo55的结构为例,原始640 · 640 · 3的图像输入 FoCus结构,采用切片操作,先变成320 · 320 · 12的特征图,再经过一次32个卷积核的卷积操作,最终变成320 · 320 · 32的特征图。</p><p>YOLOv5-python代码如下:</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Focus: 把宽度w和高度h的信息整合到c空间中</span><span class="token keyword">class</span> <span class="token class-name">Focus</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Focus wh information into c-space</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> p<span class="token operator">=</span>None<span class="token punctuation">,</span> g<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> act<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># ch_in, ch_out, kernel, stride, padding, groups</span>        super<span class="token punctuation">(</span>Focus<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv <span class="token operator">=</span> Conv<span class="token punctuation">(</span>c1 <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">,</span> c2<span class="token punctuation">,</span> k<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">,</span> g<span class="token punctuation">,</span> act<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># x(b,c,w,h) -> y(b,4c,w/2,h/2)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>conv<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>**绿色框（SPP)**代表：空间最大池化，先做蓝色框（Conv）,再做最大值池化，再做拼接，再做蓝色框（Conv）。将SPP块添加到CSP上之后，会极大地增加了模型的感知能力，分离出特征图的最大特征。并且不会影响网络运行速度。</p><p>YOLOv5-python代码如下:</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 空间金字塔池化</span><span class="token keyword">class</span> <span class="token class-name">SPP</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Spatial pyramid pooling layer used in YOLOv3-SPP</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>SPP<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        c_ <span class="token operator">=</span> c1 <span class="token operator">//</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># hidden channels</span>        self<span class="token punctuation">.</span>cv1 <span class="token operator">=</span> Conv<span class="token punctuation">(</span>c1<span class="token punctuation">,</span> c_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>cv2 <span class="token operator">=</span> Conv<span class="token punctuation">(</span>c_ <span class="token operator">*</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>m <span class="token operator">=</span> nn<span class="token punctuation">.</span>ModuleList<span class="token punctuation">(</span><span class="token punctuation">[</span>nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span>x<span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span>x <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> k<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>cv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cv2<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>m<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> m <span class="token keyword">in</span> self<span class="token punctuation">.</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>==灵活配置不同复杂度的模型==</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210625105957047.png"></p><p>YOLOV5的四种网络结构是 depth multiple和 width multiple两个参数,来进行控制网络的深度和宽度。其中depth multiple控制网络的深度( Bottlenecks数), width multiple控制网络的宽度(卷积核数量)。</p><h3 id="2-3-数据集创建（dataset-py）"><a href="#2-3-数据集创建（dataset-py）" class="headerlink" title="2.3 数据集创建（dataset.py）"></a>2.3 数据集创建（dataset.py）</h3><p>1、矩形推理和方形推理</p><p>方形推理：将图像的短边填充为长边的长度<br>        矩形推理：将短边填充为32的最小整数倍</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210625150730777.png"></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 图像缩放: 保持图片的宽高比例，剩下的部分采用灰色填充。</span><span class="token keyword">def</span> <span class="token function">letterbox</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> new_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">114</span><span class="token punctuation">)</span><span class="token punctuation">,</span> auto<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> scaleFill<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> scaleup<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># Resize image to a 32-pixel-multiple rectangle https://github.com/ultralytics/yolov3/issues/232</span>    shape <span class="token operator">=</span> img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># current shape [height, width]</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>new_shape<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>        new_shape <span class="token operator">=</span> <span class="token punctuation">(</span>new_shape<span class="token punctuation">,</span> new_shape<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Scale ratio (new / old) # 计算缩放因子</span>    r <span class="token operator">=</span> min<span class="token punctuation">(</span>new_shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> new_shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token triple-quoted-string string">"""    缩放(resize)到输入大小img_size的时候，如果没有设置上采样的话，则只进行下采样    因为上采样图片会让图片模糊，对训练不友好影响性能。    """</span>    <span class="token keyword">if</span> <span class="token operator">not</span> scaleup<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># only scale down, do not scale up (for better test mAP)</span>        r <span class="token operator">=</span> min<span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Compute padding</span>    ratio <span class="token operator">=</span> r<span class="token punctuation">,</span> r  <span class="token comment" spellcheck="true"># width, height ratios</span>    new_unpad <span class="token operator">=</span> int<span class="token punctuation">(</span>round<span class="token punctuation">(</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>round<span class="token punctuation">(</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>    dw<span class="token punctuation">,</span> dh <span class="token operator">=</span> new_shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> new_unpad<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> new_shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> new_unpad<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># wh padding</span>    <span class="token keyword">if</span> auto<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># minimum rectangle # 获取最小的矩形填充</span>        dw<span class="token punctuation">,</span> dh <span class="token operator">=</span> np<span class="token punctuation">.</span>mod<span class="token punctuation">(</span>dw<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>mod<span class="token punctuation">(</span>dh<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># wh padding</span>    <span class="token comment" spellcheck="true"># 如果scaleFill=True,则不进行填充，直接resize成img_size, 任由图片进行拉伸和压缩</span>    <span class="token keyword">elif</span> scaleFill<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># stretch</span>        dw<span class="token punctuation">,</span> dh <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span>        new_unpad <span class="token operator">=</span> <span class="token punctuation">(</span>new_shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> new_shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        ratio <span class="token operator">=</span> new_shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> new_shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># width, height ratios</span>    <span class="token comment" spellcheck="true"># 计算上下左右填充大小</span>    dw <span class="token operator">/=</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># divide padding into 2 sides</span>    dh <span class="token operator">/=</span> <span class="token number">2</span>    <span class="token keyword">if</span> shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> new_unpad<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># resize</span>        img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img<span class="token punctuation">,</span> new_unpad<span class="token punctuation">,</span> interpolation<span class="token operator">=</span>cv2<span class="token punctuation">.</span>INTER_LINEAR<span class="token punctuation">)</span>    top<span class="token punctuation">,</span> bottom <span class="token operator">=</span> int<span class="token punctuation">(</span>round<span class="token punctuation">(</span>dh <span class="token operator">-</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>round<span class="token punctuation">(</span>dh <span class="token operator">+</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> int<span class="token punctuation">(</span>round<span class="token punctuation">(</span>dw <span class="token operator">-</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> int<span class="token punctuation">(</span>round<span class="token punctuation">(</span>dw <span class="token operator">+</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 进行填充</span>    img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span> top<span class="token punctuation">,</span> bottom<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span> value<span class="token operator">=</span>color<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># add border</span>    <span class="token keyword">return</span> img<span class="token punctuation">,</span> ratio<span class="token punctuation">,</span> <span class="token punctuation">(</span>dw<span class="token punctuation">,</span> dh<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> YOLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【YOLOv5】初体验</title>
      <link href="/2021/06/15/yolov5-chu-ti-yan/"/>
      <url>/2021/06/15/yolov5-chu-ti-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="【YOLOv5】初体验"><a href="#【YOLOv5】初体验" class="headerlink" title="【YOLOv5】初体验"></a>【YOLOv5】初体验</h1><h2 id="1、-Yolov5简介"><a href="#1、-Yolov5简介" class="headerlink" title="1、 Yolov5简介"></a>1、 Yolov5简介</h2><p>Yolov5官方代码中，给出的目标检测网络中一共有4个版本，分别是<strong>Yolov5s、Yolov5m、Yolov5l、Yolov5x</strong>四个模型。</p><p>Yolov5的结构和Yolov4很相似，但也有一些不同。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/v2-770a51ddf78b084affff948bb522b6c0_720w.jpg"></p><p>上图即<strong>Yolov5</strong>的网络结构图，可以看出，还是分为<strong>输入端、Backbone、Neck、Prediction</strong>四个部分。</p><p>大家可能对<strong>Yolov3</strong>比较熟悉，因此大白列举它和Yolov3的一些主要的不同点，并和Yolov4进行比较。</p><p>​    <strong>（1）输入端：</strong>Mosaic数据增强、自适应锚框计算、自适应图片缩放<br>​            <strong>（2）Backbone：</strong>Focus结构，CSP结构<br>​            <strong>（3）Neck：</strong>FPN+PAN结构<br>​            <strong>（4）Prediction：</strong>GIOU_Loss</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210618092709617.png"></p><p>Yolov5作者也是在COCO数据集上进行的测试，COCO数据集的小目标占比，因此最终的四种网络结构，性能上来说各有千秋。Yolov5s网络最小，速度最少，AP精度也最低。但如果检测的以大目标为主，追求速度，倒也是个不错的选择。其他的三种网络，在此基础上，不断加深加宽网络，AP精度也不断提升，但速度的消耗也在不断增加。</p><p><strong>总结：在目标检测领域，速度比YOLO快的，精度基本没有YOLO高。精度比YOLO高的，速度基本没有YOLO快。</strong></p><h2 id="2、环境依赖"><a href="#2、环境依赖" class="headerlink" title="2、环境依赖"></a>2、环境依赖</h2><p><strong>本人环境声明：</strong></p><p><strong>主机：</strong><code>极链AI云GPU服务器，GPU为TITAN Xp 24。配置如下。</code></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210618093419130.png"></p><p><strong>系统：</strong><code>ubuntu 18.04</code></p><p><strong>开发工具：</strong><code>vscode+ssh</code></p><p><strong>step1、克隆项目</strong></p><p>YOLOv5源码托管在github上：</p><pre class=" language-shell"><code class="language-shell">git clone https://github.com/ultralytics/yolov5.git</code></pre><p><strong>step2、安装必要的环境</strong></p><ol><li>下载[<a href="https://www.anaconda.com/products/individual#linux">Anaconda</a>]，执行安装指令：<pre class=" language-shell"><code class="language-shell">bash /your_dir/Anaconda3-2021.05-Linux-x86_64.sh</code></pre></li></ol><p>如若不更改安装路径，一直回车或者输入yes即可完成安装</p><p>接下来创建YOLOv5的虚拟环境，以便于隔离不同Python版本之间的影响：</p><pre class=" language-shell"><code class="language-shell">conda create --name YOLOv5 python=3.8#创建虚拟环境conda activate YOLOv5#激活虚拟环境</code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210618094815452.png"></p><ol start="2"><li><p>安装Pytorch,在官网可以找到安装指令，选择Stable(1.9.0)版本，Linux操作系统，Conda开发环境，Python开发语言，CUDA 11.1。便能得到安装指令：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210618100100769.png"></p></li></ol><pre class=" language-shell"><code class="language-shell">conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c nvidia</code></pre><ol start="3"><li>安装其他必备环境，YOLOv5其他必备环境都写在代码包里面，有个requirements.txt文件，其中包括了一些基本的必备环境。只需执行如下指令即可安装。</li></ol><pre class=" language-shell"><code class="language-shell">pip install -U -r requirements.txt</code></pre><h2 id="3-、设置样本数据和标签"><a href="#3-、设置样本数据和标签" class="headerlink" title="3 、设置样本数据和标签"></a>3 、设置样本数据和标签</h2><p>此次样本数据来自某电厂的仪器仪表数据，主要是识别照片中的仪器仪表位置。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210618104902350.png"></p><p>  首先，通过一个简单的脚本rename.py为这些照片进行重命名:</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#rename.py</span><span class="token comment" spellcheck="true">#coding:UTF-8</span><span class="token keyword">import</span> osfolder_path <span class="token operator">=</span> <span class="token string">"/样本数据的路径/"</span>file_list <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>folder_path<span class="token punctuation">)</span>os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span>folder_path<span class="token punctuation">)</span>   n<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">for</span> old_name <span class="token keyword">in</span> file_list<span class="token punctuation">:</span>    new_name <span class="token operator">=</span> <span class="token string">"image"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">".JPG"</span>    os<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>old_name<span class="token punctuation">,</span> new_name<span class="token punctuation">)</span>    n<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span></code></pre><p>可以得到如下结果：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210618105318363.png"></p><p>接下来，为样本数据设置标签（labels）。这里使用的labelImg工具。可以直接使pip安装</p><pre class=" language-shell"><code class="language-shell">pip isntall labelImg#安装labelImg</code></pre><p><code>labelImg</code>是一款是用于制作数据集时，对数据集进行标注的工具，labelImg是深度学习最常用的标注工具之一。</p><p><strong>注意：labels文件夹应和images文件在同一路径下。且labels文件夹下应有一个名为classes.txt文件，里面写着分类类别。</strong></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/llll.png"></p><p>运行方法为在命令行工具（Windows下可以是CMD 、Powershell等），指定image路径和分类标签路径。</p><pre class=" language-shell"><code class="language-shell">label /image路径/   /label标签保存路径/classs.txt</code></pre><p>之后会弹出labelImg的UI页面：将数据格式设置为YOLO才能生成txt格式的标签，按W快速选择目标区域，按A/D为上一张/下一张。 </p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210619142519252.png"></p><p>标记完所有图片后会得到如图所示的文件结构：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210619151051478.png"></p><p>至此，样本数据就准备完毕。</p><h2 id="4、正式训练模型"><a href="#4、正式训练模型" class="headerlink" title="4、正式训练模型"></a>4、正式训练模型</h2><p>在YOLOv5项目的<code>./models</code>文件夹下选择一个需要训练的模型，这里我们选择yolov5s.yaml,最小的一个模型进行训练，参考官方README中的<a href="https://github.com/ultralytics/yolov5#pretrained-checkpoints">table</a>,了解不同模型的大小和推断速度。如果你选定了一个模型，那么需要修改模型对应的<code>yaml</code>文件</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># parameters</span><span class="token key atrule">nc</span><span class="token punctuation">:</span> <span class="token number">3  </span><span class="token comment" spellcheck="true"># number of classes     &lt;------------> 设置为自己数据集的类别个数</span><span class="token key atrule">depth_multiple</span><span class="token punctuation">:</span> <span class="token number">0.33  </span><span class="token comment" spellcheck="true"># model depth multiple</span><span class="token key atrule">width_multiple</span><span class="token punctuation">:</span> <span class="token number">0.50  </span><span class="token comment" spellcheck="true"># layer channel multiple</span><span class="token comment" spellcheck="true"># anchors</span><span class="token key atrule">anchors</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># P3/8</span>  <span class="token punctuation">-</span> <span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">61</span><span class="token punctuation">,</span> <span class="token number">62</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span><span class="token number">119</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># P4/16</span>  <span class="token punctuation">-</span> <span class="token punctuation">[</span><span class="token number">116</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">156</span><span class="token punctuation">,</span><span class="token number">198</span><span class="token punctuation">,</span> <span class="token number">373</span><span class="token punctuation">,</span><span class="token number">326</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># P5/32</span><span class="token comment" spellcheck="true"># YOLOv5 backbone</span><span class="token key atrule">backbone</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># [from, number, module, args]</span>  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Focus<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 0-P1/2</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 1-P2/4</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 3-P3/8</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 5-P4/16</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 7-P5/32</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> SPP<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token boolean important">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 9</span>  <span class="token punctuation">]</span><span class="token comment" spellcheck="true"># YOLOv5 head</span><span class="token key atrule">head</span><span class="token punctuation">:</span>  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> nn.Upsample<span class="token punctuation">,</span> <span class="token punctuation">[</span>None<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'nearest'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># cat backbone P4</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token boolean important">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 13</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> nn.Upsample<span class="token punctuation">,</span> <span class="token punctuation">[</span>None<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'nearest'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># cat backbone P3</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token boolean important">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 17 (P3/8-small)</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># cat head P4</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token boolean important">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 20 (P4/16-medium)</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Conv<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Concat<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># cat head P5</span>   <span class="token punctuation">[</span><span class="token number">-1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> C3<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token boolean important">False</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 23 (P5/32-large)</span>   <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> Detect<span class="token punctuation">,</span> <span class="token punctuation">[</span>nc<span class="token punctuation">,</span> anchors<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># Detect(P3, P4, P5)</span>  <span class="token punctuation">]</span></code></pre><p>参考官方的数据集格式，需要通过一个yaml文件指定数据集的来源。故而新建一个data.yaml文件放在data文件下，容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]</span><span class="token key atrule">train</span><span class="token punctuation">:</span> /root/yolov51/mydata/images/  <span class="token comment" spellcheck="true"># 训练数据集</span><span class="token key atrule">val</span><span class="token punctuation">:</span> /root/yolov51/mydata/images/  <span class="token comment" spellcheck="true"># 测试数据集</span><span class="token comment" spellcheck="true"># number of classes</span><span class="token key atrule">nc</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token comment" spellcheck="true"># class names</span><span class="token key atrule">names</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'Pointer-instrument'</span><span class="token punctuation">,</span><span class="token string">'Digital-display-instrument'</span><span class="token punctuation">,</span><span class="token string">'Indicator-light'</span> <span class="token punctuation">]</span></code></pre><p>做好以上准备工作后，就可以开始训练，YOLOv5的训练文件为：train.py。在阅读源码后，发现至少需要指定如下参数才能正常训练：</p><pre class=" language-shell"><code class="language-shell"># Train yolov5x on score for 300 epochspython train.py --img-size 640  --epochs 300 --data ./data/mydata.yaml --cfg ./models/yolov5s.yaml --weights ./yolov5s.pt</code></pre><ul><li><code> --img-size</code>：输入图片的大小</li><li><code>--epochs</code>：训练步长</li><li><code>--data </code>:数据集配置文件</li><li><code>--cfg </code>：模型配置文件</li><li><code>--weights</code>：权重配置文件</li></ul><p>开始训练后会出现如下结果，则表示训练正常：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210619125153656.png"></p><p>训练之后生成的结果会通过<code>tensorboard </code>在浏览器中打开，权重文件会保存在./runs/train/expN/weights/中，里面会有best.pt和last.pt两个文件。</p><p>可以看到随训练生成的分析统计：</p><p>比如，三类仪表的个数和在图片中的位置统计如下：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/labels.jpg"><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/labels_correlogram.jpg"></p><p>最后：对于验证数据集测试效果如下：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/test_batch0_pred.jpg"></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/test_batch1_pred.jpg"></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/test_batch2_pred.jpg"></p><h2 id="5、检测仪表位置"><a href="#5、检测仪表位置" class="headerlink" title="5、检测仪表位置"></a>5、检测仪表位置</h2><p>YOLOv5中提供了detect.py脚本，可以检测单张图片，多张图片，以及视频。</p><p>单张图片测试命令：</p><pre class=" language-python"><code class="language-python">python detect<span class="token punctuation">.</span>py <span class="token operator">-</span><span class="token operator">-</span>source inference<span class="token operator">/</span>image0<span class="token punctuation">.</span>jpg <span class="token operator">-</span><span class="token operator">-</span>weights <span class="token punctuation">.</span><span class="token operator">/</span>runs<span class="token operator">/</span>train<span class="token operator">/</span>expN<span class="token operator">/</span>weights<span class="token operator">/</span>best<span class="token punctuation">.</span>pt </code></pre><p>预测结构会保存在./runs/detect/中</p><p>这里以一段视频为例：</p><pre class=" language-shell"><code class="language-shell">python detect.py --source /YourMP4dir/test.mp4 --weights ./runs/train/expN/weights/best.pt </code></pre><p>结果如下：</p><p><video width="720" height="303" controls> #或者：&lt;video width:60% height:auto controls&gt;</p><source src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image261.MP4" type="video/mp4"></video><p><video width="720" height="303" controls> #或者：&lt;video width:60% height:auto controls&gt;</p><source src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image263.MP4" type="video/mp4"></video>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汽车油耗预测实战</title>
      <link href="/2021/05/21/you-hao-yu-ce/"/>
      <url>/2021/05/21/you-hao-yu-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="汽车油耗预测实战"><a href="#汽车油耗预测实战" class="headerlink" title="汽车油耗预测实战"></a>汽车油耗预测实战</h1><p>将利用全连接网络模型来完成汽车的效能指标MPG(Mile Per Gallon，每加仑燃油英里数)的预测问题实战</p><h2 id="1-、数据集"><a href="#1-、数据集" class="headerlink" title="1 、数据集"></a>1 、数据集</h2><p>采用<a href="http://archive.ics.uci.edu/ml/machine-learning-databases/">http://archive.ics.uci.edu/ml/machine-learning-databases/</a> 上的Auto-MPG 数据集，它记录了各种汽车效能指标与气缸数、重量、马力等其它因子的真实数据，查看数据集的前5 项，。除了产地的数字字段表示类别外，其他字段都是数值类型。对于产地地段，1 表示美国，2 表示欧洲，3 表示日本。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210520124026048.png"></p><table><thead><tr><th>MPG</th><th>Cylinders</th><th>Displacement</th><th>Horsepower</th><th>Weight</th><th>Acceleration</th><th>Model Year</th><th>Origin</th></tr></thead><tbody><tr><td>每加<br/>仑燃<br/>油英<br/>里</td><td>气缸数</td><td>排量</td><td>马力</td><td>重量</td><td>加速度</td><td>型号</td><td>年份</td></tr></tbody></table><p>Auto MPG 数据集一共记录了398 项数据，UCI 服务器下载并读取数据集到DataFrame 对象中，代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      dataset_path <span class="token operator">=</span> keras<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>get_file<span class="token punctuation">(</span><span class="token string">"auto-mpg.data"</span><span class="token punctuation">,</span><span class="token string">"http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data"</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># 效能（公里数每加仑），气缸数，排量，马力，重量</span>      <span class="token comment" spellcheck="true"># 加速度，型号年份，产地</span>      column_names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'MPG'</span><span class="token punctuation">,</span> <span class="token string">'Cylinders'</span><span class="token punctuation">,</span> <span class="token string">'Displacement'</span><span class="token punctuation">,</span> <span class="token string">'Horsepower'</span><span class="token punctuation">,</span> <span class="token string">'Weight'</span><span class="token punctuation">,</span>                      <span class="token string">'Acceleration'</span><span class="token punctuation">,</span> <span class="token string">'Model Year'</span><span class="token punctuation">,</span> <span class="token string">'Origin'</span><span class="token punctuation">]</span>      raw_dataset <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>dataset_path<span class="token punctuation">,</span> names<span class="token operator">=</span>column_names<span class="token punctuation">,</span>                                na_values<span class="token operator">=</span><span class="token string">"?"</span><span class="token punctuation">,</span> comment<span class="token operator">=</span><span class="token string">'\t'</span><span class="token punctuation">,</span>                                sep<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">,</span> skipinitialspace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>      dataset <span class="token operator">=</span> raw_dataset<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> dataset<span class="token comment" spellcheck="true"># 查看部分数据</span>dataset<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>输出如图所示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210520124255726.png"></p><p>原始表格中的数据可能含有空字段(缺失值)的数据项，需要清除这些记录项。并且由于 Origin 字段为类别类型数据，我们将其移除，并转换为新的3 个字段：USA、Europe 和Japan，分别代表是否来自此产地。按着8:2 的比例切分数据集为训练集和测试集。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">preprocess_dataset</span><span class="token punctuation">(</span>dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 统计空白数据,并清除</span>    dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 处理类别型数据，其中origin列代表了类别1,2,3,分布代表产地：美国、欧洲、日本</span>    <span class="token comment" spellcheck="true"># 其弹出这一列</span>    origin <span class="token operator">=</span> dataset<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'Origin'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 根据origin列来写入新列</span>    dataset<span class="token punctuation">[</span><span class="token string">'USA'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>origin <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.0</span>    dataset<span class="token punctuation">[</span><span class="token string">'Europe'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>origin <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.0</span>    dataset<span class="token punctuation">[</span><span class="token string">'Japan'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>origin <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.0</span>    <span class="token comment" spellcheck="true"># 切分为训练集和测试集</span>    train_dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>frac<span class="token operator">=</span><span class="token number">0.8</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    test_dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>train_dataset<span class="token punctuation">.</span>index<span class="token punctuation">)</span>    <span class="token keyword">return</span> train_dataset<span class="token punctuation">,</span> test_dataset</code></pre><p>统计得到的训练集和测试集数据：</p><pre class=" language-python"><code class="language-python">train_dataset<span class="token punctuation">,</span> test_dataset <span class="token operator">=</span> preprocess_dataset<span class="token punctuation">(</span>dataset<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 统计数据</span>sns_plot <span class="token operator">=</span> sns<span class="token punctuation">.</span>pairplot<span class="token punctuation">(</span>train_dataset<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"Cylinders"</span><span class="token punctuation">,</span> <span class="token string">"Displacement"</span><span class="token punctuation">,</span> <span class="token string">"Weight"</span><span class="token punctuation">,</span> <span class="token string">"MPG"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> diag_kind<span class="token operator">=</span><span class="token string">"kde"</span><span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E4%B8%8B%E8%BD%BD.png"></p><p>统计训练集的各个字段数值的均值和标准差，并完成数据的标准化，通过norm()函数实现，代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 查看训练集的输入X的统计数据</span>train_stats <span class="token operator">=</span> train_dataset<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span>train_stats<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">"MPG"</span><span class="token punctuation">)</span>train_stats <span class="token operator">=</span> train_stats<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token punctuation">)</span>train_stats<span class="token keyword">def</span> <span class="token function">norm</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> train_stats<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    标准化数据    :param x:    :param train_stats: get_train_stats(train_dataset)    :return:    """</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> train_stats<span class="token punctuation">[</span><span class="token string">'mean'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> train_stats<span class="token punctuation">[</span><span class="token string">'std'</span><span class="token punctuation">]</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210520125501217.png"></p><p>打印出训练集和测试集的大小：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 移动MPG油耗效能这一列为真实标签Y</span>train_labels <span class="token operator">=</span> train_dataset<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'MPG'</span><span class="token punctuation">)</span>test_labels <span class="token operator">=</span> test_dataset<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'MPG'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 进行标准化</span>normed_train_data <span class="token operator">=</span> norm<span class="token punctuation">(</span>train_dataset<span class="token punctuation">,</span> train_stats<span class="token punctuation">)</span>normed_test_data <span class="token operator">=</span> norm<span class="token punctuation">(</span>test_dataset<span class="token punctuation">,</span> train_stats<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>normed_train_data<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>train_labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>normed_test_data<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> test_labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre><p>得到结果：</p><p>(314, 9) (314,) # 训练集共314 行，输入特征长度为9,标签用一个标量表示</p><p>(78, 9) (78,) # 测试集共78 行，输入特征长度为9,标签用一个标量表示</p><p>可以通过简单地统计数据集中各字段之间的两两分布来观察各个字段对MPG 的影响。可以大致观察到，其中汽车排量、重量与MPG 的关系比较简单，随着排量或重量的增大，汽车的MPG 降低，能耗增加；气缸数越小，汽车能做到的最好MPG 也越高，越可能更节能，这都是是符合我们的生活经验的。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/yuce.jpg"></p><h2 id="2-、创建网络"><a href="#2-、创建网络" class="headerlink" title="2 、创建网络"></a>2 、创建网络</h2><p>考虑到 Auto-MPG 数据集规模较小，我们只创建一个3 层的全连接网络来完成MPG值的预测任务。输入𝑿的特征共有9 种，因此第一层的输入节点数为9。第一层、第二层的输出节点数设计为64和64，由于只有一种预测值，输出层输出节点设计为1。考虑MPG ∈𝑅+，因此输出层的激活函数可以不加，也可以添加ReLU 激活函数。</p><p>将网络实现为一个自定义网络类，只需要在初始化函数中创建各个子网络层，并在前向计算函数call 中实现自定义网络类的计算逻辑即可。自定义网络类继承自keras.Model 基类，这也是自定义网络类的标准写法，以方便地利用keras.Model 基类提供的trainable_variables、save_weights 等各种便捷功能。网络模型类实现如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Network</span><span class="token punctuation">(</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 回归网络</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>Network<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 创建3个全连接层</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc3 <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 依次通过3个全连接层</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>fc3<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> x</code></pre><h2 id="3、测试和训练"><a href="#3、测试和训练" class="headerlink" title="3、测试和训练"></a>3、测试和训练</h2><p>在完成主网络模型类的创建后，我们来实例化网络对象和创建优化器，代码如下:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">build_model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    model <span class="token operator">=</span> Network<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 创建网络</span>    model<span class="token punctuation">.</span>build<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过build 函数完成内部张量的创建，其中4 为任意设置的batch 数量，9 为输入特征长度</span>    model<span class="token punctuation">.</span>summary<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 打印网络信息</span>    <span class="token keyword">return</span> modelmodel <span class="token operator">=</span> build_model<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#创建模型</span>optimizer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>optimizers<span class="token punctuation">.</span>RMSprop<span class="token punctuation">(</span><span class="token number">0.001</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建优化器，指定学习率</span>train_db <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span><span class="token punctuation">(</span>normed_train_data<span class="token punctuation">.</span>values<span class="token punctuation">,</span> train_labels<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span>train_db <span class="token operator">=</span> train_db<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span></code></pre><p>得到网络结构如图所示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210520131435918.png"></p><p>接下来实现网络训练部分。通过Epoch 和Step 组成的双层循环训练网络，共训练200个Epoch，代码如下:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> train_db<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> normed_test_data<span class="token punctuation">,</span> test_labels<span class="token punctuation">)</span><span class="token punctuation">:</span>    train_mae_losses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    test_mae_losses <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 200 个Epoch</span>        <span class="token keyword">for</span> step<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>train_db<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 遍历一次训练集</span>            <span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 梯度记录器，训练时需要使用它</span>                out <span class="token operator">=</span> model<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#通过网络得到输出</span>                loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>losses<span class="token punctuation">.</span>MSE<span class="token punctuation">(</span>y<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算MSE</span>                mae_loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>losses<span class="token punctuation">.</span>MAE<span class="token punctuation">(</span>y<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 计算MAE</span>            <span class="token keyword">if</span> step <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 间隔性地打印训练误差</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> step<span class="token punctuation">,</span> float<span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 计算梯度，并更新</span>            grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> model<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span>            optimizer<span class="token punctuation">.</span>apply_gradients<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>grads<span class="token punctuation">,</span> model<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token punctuation">)</span>        train_mae_losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>float<span class="token punctuation">(</span>mae_loss<span class="token punctuation">)</span><span class="token punctuation">)</span>        out <span class="token operator">=</span> model<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span>normed_test_data<span class="token punctuation">.</span>values<span class="token punctuation">)</span><span class="token punctuation">)</span>        test_mae_losses<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>losses<span class="token punctuation">.</span>MAE<span class="token punctuation">(</span>test_labels<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> train_mae_losses<span class="token punctuation">,</span> test_mae_losses</code></pre><p>执行如下代码即可完成整个模型的训练：</p><pre class=" language-python"><code class="language-python">train_mae_losses<span class="token punctuation">,</span> test_mae_losses <span class="token operator">=</span> train<span class="token punctuation">(</span>model<span class="token punctuation">,</span> train_db<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> normed_test_data<span class="token punctuation">,</span> test_labels<span class="token punctuation">)</span></code></pre><p>对于回归问题，除了MSE 均方差可以用来模型的测试性能，还可以用平均绝对误差(Mean Absolute Error，简称MAE)来衡量模型的性能，它被定义为：<br>$$<br>MAS = \frac{1}{d_{out}}\sum_{i}|y_i - o_i|<br>$$<br>程序运算时记录每个Epoch 结束时的训练和测试MAE 数据，并绘制变化曲线，在执行过程中，可以明确的看到，随着Epoch 的增加，MAS明显减小。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">plot</span><span class="token punctuation">(</span>train_mae_losses<span class="token punctuation">,</span> test_mae_losses<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Epoch'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'MAE'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>train_mae_losses<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Train'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>test_mae_losses<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Test'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># plt.ylim([0,10])</span>    plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>plot<span class="token punctuation">(</span>train_mae_losses<span class="token punctuation">,</span> test_mae_losses<span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/finallyout.png"></p><p>可以观察到，在训练到约第25 个Epoch 时，MAE 的下降变得较缓慢，其中训练集的MAE还在继续缓慢下降，但是测试集MAE 几乎保持不变，因此可以在约第25 个epoch 时提前结束训练，并利用此时的网络参数来预测新的输入样本即可。</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【树莓派】OpenCV3源码方式安装教程</title>
      <link href="/2021/03/31/opencv-an-zhuang-jiao-cheng/"/>
      <url>/2021/03/31/opencv-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="【树莓派】OpenCV3源码方式安装教程"><a href="#【树莓派】OpenCV3源码方式安装教程" class="headerlink" title="【树莓派】OpenCV3源码方式安装教程"></a>【树莓派】OpenCV3源码方式安装教程</h1><h2 id="一、首先我们要安装OpenCV所依赖的各种工具和图像视频库："><a href="#一、首先我们要安装OpenCV所依赖的各种工具和图像视频库：" class="headerlink" title="一、首先我们要安装OpenCV所依赖的各种工具和图像视频库："></a>一、首先我们要安装OpenCV所依赖的各种工具和图像视频库：</h2><p> 软件源更新,升级本地所有安装包，最新系统可以不升级，版本过高反而需要降级才能安装, 升级树莓派固件，固件比较新或者是Ubuntu则不用执行：</p><pre class=" language-shell"><code class="language-shell">sudo apt-get update sudo apt-get upgradesudo rpi-update  </code></pre><p>然后安装构建OpenCV的相关工具，安装build-essential、cmake、git和pkg-config</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install build-essential cmake git pkg-config </code></pre><p>之后安装常用图像工具包：安装jpeg格式图像工具包、  安装tif格式图像工具包 、安装JPEG-2000图像工具包 、安装png图像工具包：</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install libjpeg8-dev sudo apt-get install libtiff5-dev sudo apt-get install libjasper-dev sudo apt-get install libpng12-dev </code></pre><p>再安装视频I/O包：</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev</code></pre><p>下面安装gtk2.0（树莓派很可能下载错误，更换中科大或者清华源即可，ubuntu有可能出现包版本过高的情况，需要将依赖包降级安装）:</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install libgtk2.0-dev</code></pre><p>优化函数包：</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install libatlas-base-dev gfortran</code></pre><p>如果你希望在Python中使用OpenCV，那么你还需要安装Python的开发包:</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install python-dev python3-dev</code></pre><h2 id="二、下载源码并且Cmake编译"><a href="#二、下载源码并且Cmake编译" class="headerlink" title="二、下载源码并且Cmake编译"></a>二、下载源码并且Cmake编译</h2><p>在树莓派上目录：</p><pre class=" language-shell"><code class="language-shell">wget -O opencv-3.4.3.zip https://github.com/Itseez/opencv/archive/3.4.3.zipwget -O opencv_contrib-3.4.3.zip https://github.com/Itseez/opencv_contrib/archive/3.4.3.zipunzip opencv-3.4.3.zipunzip opencv_contrib-3.4.3.zip</code></pre><p>打开源码文件夹</p><pre class=" language-shell"><code class="language-shell">cd opencv-3.4.3mkdir releasecd release</code></pre><p>设置cmake编译参数，安装目录默认为/usr/local ，注意参数名、等号和参数值之间不能有空格，但每行末尾“\”之前有空格，参数值最后是两个英文的点(注意！如果在root用户下执行cmake命令，请将OPENCV_EXTRA_MODULES_PATH的值改为绝对路径，如：/home/pi/opencv_contrib-3.4.3/modules)：</p><pre class=" language-shell"><code class="language-shell">/** CMAKE_BUILD_TYPE是编译方式* CMAKE_INSTALL_PREFIX是安装目录* OPENCV_EXTRA_MODULES_PATH是加载额外模块* INSTALL_PYTHON_EXAMPLES是安装官方python例程* BUILD_EXAMPLES是编译例程（这两个可以不加，不加编译稍微快一点点，想要C语言的例程的话，在最后一行前加参数INSTALL_C_EXAMPLES=ON \）**/sudo cmake -D CMAKE_BUILD_TYPE=RELEASE \    -D CMAKE_INSTALL_PREFIX=/usr/local \    -D OPENCV_EXTRA_MODULES_PATH=/home/pi/opencv_contrib-3.4.3/modules \    -D INSTALL_PYTHON_EXAMPLES=ON \    -D BUILD_EXAMPLES=ON ..</code></pre><p>之后开始正式编译过程（如果之前一步因为网络问题导致cmake下载缺失文件失败的话，可以尝试使用手机热点，并将release文件夹删除掉，重新创建release文件夹并cmake）：</p><p>编译，以管理员身份，否则容易出错</p><p>make命令参数-j4指允许make使用最多4个线程进行编译</p><pre class=" language-shell"><code class="language-shell">sudo make -j4</code></pre><p>安装:</p><pre class=" language-shell"><code class="language-shell">sudo make install</code></pre><p>更新动态链接库:</p><pre class=" language-shell"><code class="language-shell">sudo ldconfig</code></pre><h2 id="三、报错与解决"><a href="#三、报错与解决" class="headerlink" title="三、报错与解决"></a>三、报错与解决</h2><p>一般来说，会遇到两个问题：</p><p>第一，是某个文件找不到，解决方法就是，将文件中的相对路径改成绝对路径。</p><p>第二，由于Configure导致下载不全的文件列表，缺少boostdesc_bgm.i 等文件；</p><p>链接：<a href="https://pan.baidu.com/s/1pmrPG2sa8Eg0XttldeoYcA">https://pan.baidu.com/s/1pmrPG2sa8Eg0XttldeoYcA</a><br>         提取码：smmd<br>下载好文件，放到对应文件夹即可，重新编译。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(C/C++实现)</title>
      <link href="/2021/03/26/datastructandalgorithms/"/>
      <url>/2021/03/26/datastructandalgorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法-C-C-实现"><a href="#数据结构与算法-C-C-实现" class="headerlink" title="数据结构与算法(C/C++实现)"></a>数据结构与算法(C/C++实现)</h1><p>​                                                                                                                                参考书籍：《数据结构、算法与应用 C++ 语言描述》 [美]Sartaj Sahni著；<a href="http://c.biancheng.net/cpp/biancheng/view/2971.html">C语言中文网</a></p><h2 id="第一章-C-回顾"><a href="#第一章-C-回顾" class="headerlink" title="第一章 C++回顾"></a>第一章 C++回顾</h2><h3 id="1-1-C-初步"><a href="#1-1-C-初步" class="headerlink" title="1.1 C++初步"></a>1.1 C++初步</h3><h4 id="1、C-命名空间"><a href="#1、C-命名空间" class="headerlink" title="1、C++命名空间"></a>1、C++命名空间</h4><p>例如小李和小韩都参与了一个文件管理系统的开发，它们都定义了一个全局变量 fp，用来指明前打开的文件，将他们的代码整合在一起编译时，很明显编译器会提示 fp 重复定义（Redefinition）错误。</p><p>为了解决合作开发时的命名冲突问题，C++ 引入了<code>命名空间（Namespace）</code>的概念。请看下面的例子：</p><pre class=" language-c++"><code class="language-c++">namespace Li&#123;  //小李的变量定义    FILE fp = NULL;&#125;namespace Han&#123;  //小韩的变量定义    FILE fp = NULL&#125;</code></pre><p>小李与小韩各自定义了以自己姓氏为名的命名空间，此时再将他们的 fp 变量放在一起编译就不会有任何问题。</p><blockquote><p>命名空间有时也被称为名字空间、名称空间。namespace 是C++中的关键字，用来定义一个命名空间，语法格式为：</p></blockquote><pre class=" language-c++"><code class="language-c++">namespace name&#123;    //variables, functions, classes&#125;</code></pre><p><code>name</code>是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由<code>&#123; &#125;</code>包围。</p><p>使用变量、函数时要指明它们所在的命名空间。以上面的 fp 变量为例，可以这样来使用：</p><pre class=" language-c++"><code class="language-c++">Li :: fp = fopen("one.txt", "r");  //使用小李定义的变量 fpHan :: fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp</code></pre><p><code>::</code>是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。</p><p>除了直接使用域解析操作符，还可以采用 using 声明，例如：</p><pre class=" language-C++"><code class="language-C++">using Li :: fp;fp = fopen("one.txt", "r");  //使用小李定义的变量 fpHan :: fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp</code></pre><p>在代码的开头用<code>using</code>声明了<code> Li::fp</code>，它的意思是，``using <code>声明以后的程序中如果出现了未指明命名空间的 </code>fp<code>，就使用 </code>Li::fp<code>；但是若要使用小韩定义的</code> fp<code>，仍然需要 </code>Han::fp`。</p><p>using 声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间，例如：</p><pre class=" language-c++"><code class="language-c++">using namespace Li;fp = fopen("one.txt", "r");  //使用小李定义的变量 fpHan :: fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp</code></pre><p>如果命名空间 Li 中还定义了其他的变量，那么同样具有 fp 变量的效果。在 using 声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间 Li 中的变量。</p><p>命名空间内部不仅可以声明或定义变量，对于其它能在命名空间以外声明或定义的名称，同样也都能在命名空间内部进行声明或定义，例如类、函数、typedef、#define 等都可以出现在命名空间中。</p><h4 id="2、C-标准库和std命名空间"><a href="#2、C-标准库和std命名空间" class="headerlink" title="2、C++标准库和std命名空间"></a>2、C++标准库和std命名空间</h4><p>为了避免头文件重名，新版 C++ 库也对头文件的命名做了调整，去掉了后缀<code>.h</code>，所以老式 C++ 的<code>iostream.h</code>变成了<code>iostream</code>，<code>fstream.h</code>变成了<code>fstream</code>。而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个<code>c</code>字母，所以C语言的<code>stdio.h</code>变成了<code>cstdio</code>，<code>stdlib.h</code>变成了<code>cstdlib</code></p><blockquote><p>可以发现，对于不带<code>.h</code>的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带<code>.h</code>的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的</p></blockquote><p>在C语言中，我们通常会使用 scanf 和 printf 来对数据进行输入输出操作。在C++语言中，C语言的这一套输入输出库我们仍然能使用，但是 C++ 又增加了一套新的、更容易使用的输入输出库。</p><p>在C++ 中的输入与输出可以看做是一连串的数据流，输入即可视为从文件或键盘中输入程序中的一串数据流，而输出则可以视为从程序中输出一连串的数据流到显示屏或文件中。在编写 C++ 程序时，如果需要使用输入输出时，则需要包含头文件iostream<code>，包含了用于输入输出的对象，例如常见的</code>cin<code>表示标准输入、</code>cout<code>表示标准输出、</code>cerr`表示标准错误。iostream 是 Input Output Stream 的缩写，意思是“输入输出流”。cout 和 cin 都是 C++ 的内置对象，而不是关键字。</p><h4 id="3、new和delete操作符"><a href="#3、new和delete操作符" class="headerlink" title="3、new和delete操作符"></a>3、new和delete操作符</h4><p>在C语言中，动态分配内存用 malloc() 函数，释放内存用 free() 函数。如下所示：</p><pre class=" language-C++"><code class="language-C++">int *p = (int*) malloc( sizeof(int) * 10 );  //分配10个int型的内存空间free(p);  //释放内存</code></pre><p>在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。</p><pre class=" language-c++"><code class="language-c++">int *p = new int;  //分配1个int型的内存空间delete p;  //释放内存//new 操作符会根据后面的数据类型来推断所需空间的大小。//如果希望分配一组连续的数据，可以使用 new[]：int *p = new int[10];  //分配10个int型的内存空间delete[] p;</code></pre><p>用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。</p><p>和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。</p><h4 id="4、inline-内联函数"><a href="#4、inline-内联函数" class="headerlink" title="4、inline 内联函数"></a>4、inline 内联函数</h4><blockquote><p>一个 C/C++ 程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如<code>return 0;</code>）来结束自己的生命，从而结束整个程序。</p><p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p><p>如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。</p><p>为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为``内联函数（Inline Function）`，又称内嵌函数或者内置函数。</p></blockquote><p>注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。</p><p><strong>使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。</strong></p><h3 id="1-2-C-函数提高"><a href="#1-2-C-函数提高" class="headerlink" title="1.2 C++ 函数提高"></a>1.2 C++ 函数提高</h3><h4 id="1、函数参数"><a href="#1、函数参数" class="headerlink" title="1、函数参数"></a>1、函数参数</h4><p><strong>1、传值参数</strong></p><pre class=" language-c++"><code class="language-c++">int abc(int a ,int b,int)&#123;    return a+b+c;    &#125;</code></pre><p>a,b,c是<code>形参</code>，每一个形参都是整形；可以使z=abc(2,x,y)调用求和函数。那么2,x,y分别对应a,b,c的实参。形参a,b,c实际上是<code>传值参数</code>，在运行时，函数a,b,c执行前，把实参复制给形参。复制过程是由形参类型的<code>复制构造函数</code></p><p><strong>2、默认参数</strong></p><p>在C++中，函数的形参列表中的形参是可以有默认值的</p><p>语法：<code>返回值类型 函数名(参数A=默认值1，参数B=默认值2)</code></p><pre class=" language-c++"><code class="language-c++">int add(int a, int b = 10, int c = 20)&#123;    return a + b + c;&#125;//如果某个位置有默认参数，那么从这个位置往后，都必须有默认值//声明和实现只能一个有默认参数/*错误示例int add(int a, int b = 10, int c)&#123;    return a + b + c;&#125;*/</code></pre><h4 id="2、函数重载"><a href="#2、函数重载" class="headerlink" title="2、函数重载"></a>2、函数重载</h4><p><strong>作用：</strong>函数名相同，提高复用性</p><p>函数重载满足的条件：</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数类型不同，或者个数不同，或者顺序不同</li></ul><pre class=" language-c++"><code class="language-c++">int add(int a, int b)&#123;    return a + b;&#125;int add(int a, int b, int c)&#123;    return a + b + c;&#125;double add(double a, double b, double c)&#123;    return a + b + c;&#125;int main()&#123;    int m, n;    cout << " 1 : " << add(1, 2) << endl;    cout << " 2 : " << add(1, 2, 3) << endl;    cout << " 3 : " << add(1.1, 2.2, 3.3) << endl;    system("pause");    return 0;&#125;</code></pre><p>函数重载的注意事项：</p><ul><li>引用作为函数重载的条件</li><li>函数重载碰到默认参数</li></ul><p>==注意：编译器的二义性==</p><h4 id="3、模板函数"><a href="#3、模板函数" class="headerlink" title="3、模板函数"></a>3、模板函数</h4><p>假定我们希望编写另外一个函数来计算相同的表达式，不过这次a、b和c是float类型，结果也是float类型。程序1-2中给出了具体的代码。区别仅在于形参以及函数返回值的类型不同。</p><pre class=" language-c++"><code class="language-c++">float abc(float a, float b, float c)&#123;    return a+b+c;&#125;</code></pre><p>与其对每一种可能的形参类型都编写一个相应函数的新版本，不如编写一段通用代码,它的参数类型是一个变量，它的值由编译器来确定。这种通用代码使用的是模板语句。</p><pre class=" language-c++"><code class="language-c++">template <class T>T abc(T a, T b, T c)&#123;    return a+b+c;&#125;</code></pre><p>从这段通用代码，编译器通过既可T替换为int,也可把T替换为float 。事实上，通过把T替换为double或long,编译器还可以构造出函数abc的双精度型版本和长整型版本。把函数abc编写成模板函数,我们就不必了解形参的类型了。</p><h3 id="1-3-C-类和对象"><a href="#1-3-C-类和对象" class="headerlink" title="1.3 C++类和对象"></a>1.3 C++类和对象</h3><p>C++面向对象的三大特性：==封装、继承、多态==，C++任务万事万物皆为对象，对象有其属性和行为。</p><p>类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。每个对象都是类的一个具体实例，拥有类的成员变量和成员函数。</p><blockquote><p>有些教程将类的成员变量称为类的属性（Property），将类的成员函数称为类的方法（Method）。在面向对象的编程语言中，经常把函数（Function）称为方法（Method）。</p></blockquote><pre class=" language-c++"><code class="language-c++">class Student&#123;public:    //属性（Property）    string name;    int old;    float score;    //方法（Method）    void StudentInformation()    &#123;        cout << "the old of " << name << "is " << old << ","             << "and his(her) score is " << score << endl;    &#125;&#125;;</code></pre><h4 id="1、封装的意义"><a href="#1、封装的意义" class="headerlink" title="1、封装的意义"></a>1、封装的意义</h4><p><strong>访问的三种权限：</strong></p><p><code>公共权限（public）</code>：成员 类内可以访问 类外可以访问</p><p><code>保护权限（protected）</code>：成员  类内可以访问  类外不可以访问  子类可以访问父类</p><p><code>私有权限（private）</code>：成员  类内可以访问  类外不可以访问 子类不可以访问父类</p><pre class=" language-c++"><code class="language-c++">class Person&#123;public:    string m_name;protected:    int m_car;private:    int m_card_ID;public:    void func()    &#123;        m_name = "zwy";        m_car = 123;        m_card_ID = 123456;    &#125;&#125;;</code></pre><p><strong>成员属性设置为私有</strong></p><p>1、可以自己控制读写属性</p><p>2、对于写可以检测数据有效性</p><h4 id="2、对象的初始化和清理"><a href="#2、对象的初始化和清理" class="headerlink" title="2、对象的初始化和清理"></a>2、对象的初始化和清理</h4><p><strong>1、构造函数和析构函数</strong></p><p> <strong>构造函数语法</strong>：<code>类名（）&#123;&#125;</code></p><ul><li>构造函数没有返回值，也不写void</li><li>函数名与类名相同</li><li>构造函数也可以有参数，因此也可以发生重载</li><li>程序在调用对象的时候自动调用构造，无需手动调用，而且只会调用一次</li></ul><p>析构函数语法：<code>~类名（）&#123;&#125;</code></p><ul><li>析构函数没有返回值，也不写void</li><li>函数名与类名相同，在名称前加上符号 ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁的时候自动调用析构，无需手动调用，而且只会调用一次</li></ul><pre class=" language-c++"><code class="language-c++">class Person&#123;public:    Person()    &#123;        cout << "1" << endl;    &#125;    ~Person()    &#123;         cout << "2" << endl;    &#125;&#125;;</code></pre><p><strong>2、构造函数的分类</strong></p><ul><li><p>按照参数分类：无参构造（默认构造）和有参构造</p></li><li><p>按照类型分类：拷贝构造 和 普通构造（默认构造）</p><pre class=" language-C++"><code class="language-C++">//有参构造  Person(int a)&#123;    cout << "1" << endl;&#125;//拷贝构造Person(const Person &p)&#123;    //将传入类的所有属性拷贝到本个上&#125;</code></pre></li></ul><h4 id="3、函数模板"><a href="#3、函数模板" class="headerlink" title="3、函数模板"></a>3、函数模板</h4><ul><li><p>C++另一种编程思想称为泛型编程。主要利用的技术就是模板</p></li><li><p>C++提供两种模板机制:函数模板和类模板</p></li></ul><p>  <strong>函数模板语法：</strong></p><pre class=" language-C++"><code class="language-C++">//定义template<typename T>void func(T &a,T &b)&#123;    &#125;//使用func<datatype>(a,b) ;</code></pre><p>  <strong>解释：</strong></p><p>  ​    template ———声明模板</p><p>  ​    typename ——— 表明其后面的是一种数据类型，可用class替换</p><p>  ​    T ——— 通用数据类型，名称可替换，通常为大写字母</p><p>  <strong>函数模板作用:</strong>  建立-一个通用函数，其函数返回值类型和形参类型可以不具体制定,用-个虚拟的类型来代表。</p><p>  <strong>函数模板的局限性</strong>：假设有个类—人，它有两个属性—名字和年龄。能否通过函数模板直接判断是否是同一个人？</p><pre class=" language-C++"><code class="language-C++">class Person&#123;public:  string _name;  int _age;  Person(string name, int age) : _name(name), _age(age)&#123;&#125;;  ~Person()&#123;&#125;;&#125;;</code></pre><p>以下为错误示例:</p><pre class=" language-C++"><code class="language-C++">/*template <typename T>bool func(T &a, T &b)&#123;    if (a == b)        return true;    else        return false;&#125;void test_1()&#123;    Person P1("Tom", 10);    Person P2("Tom", 10);    bool re = func(P1, P2);&#125;*/</code></pre><p><strong>解决方法</strong>：</p><pre class=" language-c++"><code class="language-c++">template <typename T>bool func(T &a, T &b)&#123;    if (a == b)        return true;    else        return false;&#125;template <>bool func(Person &a, Person &b)&#123;    if (a._age == b._age && a._name == b._name)        return true;    else        return false;&#125;void test_2()&#123;    Person P1("Tom", 10);    Person P2("Tom", 10);    bool re = func<Person>(P1, P2);    cout << re << endl;&#125;</code></pre><h4 id="4、类模板"><a href="#4、类模板" class="headerlink" title="4、类模板"></a>4、类模板</h4><p>  <strong>类模板语法：</strong></p><pre class=" language-C++"><code class="language-C++">template <class nameType, class ageType = int>class Person&#123;public:  nameType _name;  ageType _age;  Person(nameType name, ageType age) : _name(name), _age(age)&#123;&#125;;  ~Person()&#123;&#125;;&#125;;</code></pre><p>  <strong>解释：</strong></p><p>  ​    template ———声明模板</p><p>  ​    typename ——— 表明其后面的是一种数据类型，可用class替换</p><p>  ​    T ——— 通用数据类型，名称可替换，通常为大写字母</p><h2 id="第二章-程序性能分析"><a href="#第二章-程序性能分析" class="headerlink" title="第二章 程序性能分析"></a>第二章 程序性能分析</h2><h3 id="2-1-空间复杂度"><a href="#2-1-空间复杂度" class="headerlink" title="2.1 空间复杂度"></a>2.1 空间复杂度</h3><p><strong>1 、空间复杂度的组成</strong><br>    程序所需要的空间主要由以下部分构成:<br>        (1)指令空间( instruction space )：指令空间是指编译之后的程序指令所需要的存储空间。</p><p>​    指令空间的数量取决于如下因素:<br>​            ●把程序转换成机器代码的编译器。<br>​            ●在编译时的编译器选项。<br>​            ●目标计算机。</p><p>(2)数据空间( data space )：数据空间是指所有常量和变量值所需要的存储空间。它由两个部分构成:</p><p>​    ●常量和简单变量所需要的存储空间。<br>​            ●动态数组和动态类实例等动态对象所需要的空间。</p><table><thead><tr><th align="center">类型</th><th align="center">空间大小</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">1</td><td align="center">{true,flase}</td></tr><tr><td align="center">char</td><td align="center">1</td><td align="center">{-128,127}</td></tr><tr><td align="center">unsigned char</td><td align="center">1</td><td align="center">{0,255}</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">{-32768,32767}</td></tr><tr><td align="center">unsigned short</td><td align="center">2</td><td align="center">{0,65535}</td></tr><tr><td align="center">long</td><td align="center">4</td><td align="center">{-2<sup>31</sup>,-2<sup>31</sup>-1}</td></tr><tr><td align="center">unsigned long</td><td align="center">4</td><td align="center">{0,2<sup>32</sup>-1}</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">{-2<sup>31</sup>,-2<sup>31</sup>-1}</td></tr><tr><td align="center">unsigned int</td><td align="center">4</td><td align="center">{0,2<sup>32</sup>-1}</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">+-3.4E+-38 (7位)</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">+-1.7E+-308(15位)</td></tr><tr><td align="center">long double</td><td align="center">10</td><td align="center">+-1.2E+-4392(19位)</td></tr></tbody></table><p>(3)环境栈空间( environment stack space )：环境栈用来保存暂停的陋数和方法在恢复运行时所需要的信息。例如，如果函数foo调用了丽数goo,那么我们至少要保存在函数goo结束时函数foo继续执行的指令地址。</p><p>●返回地址。<br>        ●正在调用的函数的所有局部变量的值以及形式参数的值( 仅对递归函数而言)。</p><h3 id="2-2-时间复杂度"><a href="#2-2-时间复杂度" class="headerlink" title="2.2 时间复杂度"></a>2.2 时间复杂度</h3><h3 id="2-3-操作计数"><a href="#2-3-操作计数" class="headerlink" title="2.3 操作计数"></a>2.3 操作计数</h3><h3 id="2-4-步数"><a href="#2-4-步数" class="headerlink" title="2.4 步数"></a>2.4 步数</h3><h2 id="第三章-线性表——数组描述"><a href="#第三章-线性表——数组描述" class="headerlink" title="第三章  线性表——数组描述"></a>第三章  线性表——数组描述</h2><h3 id="3-1-线性表的数据结构"><a href="#3-1-线性表的数据结构" class="headerlink" title="3.1 线性表的数据结构"></a>3.1 线性表的数据结构</h3><p><strong>线性表( linear list)<strong>也称</strong>有序表( ordered list)</strong>, 它的每一个实例都是元素的一一个有序集合。每一个实例的形式为(e<sub>0</sub>,e<sub>1</sub>,e<sub>2</sub>,e<sub>3</sub>…e<sub>n</sub>)其中n是有穷自然数，e<sub>i</sub> 是线性表的元素，i是元素e<sub>i</sub> 的索引，n是线性表的长度或大小。元素可以被看做原子，它们本身的结构与线性表的结构无关。当n=0时，线性表为空;当n&gt;0时，e<sub>0</sub>是线性表的第0个元素或首元素, e<sub>n-1</sub> 是线性表的最后一个元素。可以认为e<sub>0</sub>先于e<sub>1</sub>，e<sub>1</sub>先于e<sub>2</sub>等等。除了这种先后关系之外，线性表不再有其他关系。</p><p><strong>对线性表的操作</strong>：</p><ul><li>创建线性表</li></ul><pre class=" language-c"><code class="language-c">ChaLenArray <span class="token operator">*</span><span class="token function">Init_Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//初始化一个动态数组</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    ChaLenArray <span class="token operator">*</span>NewArray <span class="token operator">=</span> <span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ChaLenArray<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NewArray<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    NewArray<span class="token operator">-></span>cap <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    NewArray<span class="token operator">-></span>pAddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> NewArray<span class="token operator">-></span>cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> NewArray<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>撤销一个线性表。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">FreeSpace_Array</span><span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span>arr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//释放一个动态数组内存空间</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token operator">-></span>pAddr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* code */</span>        <span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token operator">-></span>pAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>确定线性表的长度。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Size_Array</span><span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> arr<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>按一个给定的索引查找一个元素。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">At_Array</span><span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> arr<span class="token operator">-></span>pAddr<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>按一个给定的元素查找其索引。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Find_Array</span><span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//找到一个元素</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token operator">-></span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token operator">-></span>pAddr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            pos <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pos<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>按一个给定的索引删除- -个元素。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">RemoveByPos_Array</span><span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//通过位置删除一个元素</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> pos <span class="token operator">>=</span> arr<span class="token operator">-></span>size<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        arr<span class="token operator">-></span>pAddr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token operator">-></span>pAddr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    arr<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>按一个给定的索引插入-一个元素。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Push_Back_Array</span><span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span>arr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//尾部插入一个数据</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token operator">-></span>size <span class="token operator">>=</span> arr<span class="token operator">-></span>cap<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token operator">*</span>Newspce <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>arr<span class="token operator">-></span>cap <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>Newspce<span class="token punctuation">,</span> arr<span class="token operator">-></span>pAddr<span class="token punctuation">,</span> arr<span class="token operator">-></span>cap <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token operator">-></span>pAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token operator">-></span>cap <span class="token operator">=</span> arr<span class="token operator">-></span>cap <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        arr<span class="token operator">-></span>pAddr <span class="token operator">=</span> Newspce<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    arr<span class="token operator">-></span>pAddr<span class="token punctuation">[</span>arr<span class="token operator">-></span>size<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    arr<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>从左至右顺序输出线性表元素。</li></ul><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Printf_Array</span><span class="token punctuation">(</span>ChaLenArray <span class="token operator">*</span>arr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打印</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token operator">-></span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* code */</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token operator">-></span>pAddr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="3-2-变长一维数组"><a href="#3-2-变长一维数组" class="headerlink" title="3.2 变长一维数组"></a>3.2 变长一维数组</h3><p>一维数组array,线性表元素存在array[0,n-1]中，要增加或减少这个数组长度，首先要创建一个新数组，然后把array复制到这个数组，最后改变数组array的值，是它能够引用新数组。</p><pre class=" language-c++"><code class="language-c++">//c++实现template <class T>void ChangeLength1D(T *a, int OldLength, int NewLength)&#123;    //if (NewLength <= 0)    //    throw "new length must be >=0";    T *temp = new T[NewLength];    int number = min(OldLength, NewLength);    copy(a, a + number, temp);    delete[] temp;    a = temp;&#125;//C语言实现ChaLenArray *Expand_Capacity(ChaLenArray *old_arr)&#123;    if (old_arr == NULL)        return NULL;    ChaLenArray *New_arr;    New_arr->cap = (int *)malloc(sizeof(int) * old_arr->cap * 2);    memcpy(New_arr->pAddr, old_arr->pAddr, old_arr->cap * sizeof(int));    New_arr->size = old_arr->size;    free(old_arr->pAddr);    return New_arr;&#125;</code></pre><h2 id="第四章-线性表——-链表"><a href="#第四章-线性表——-链表" class="headerlink" title="第四章 线性表—— 链表"></a>第四章 线性表—— 链表</h2><h3 id="4-1-单向链表"><a href="#4-1-单向链表" class="headerlink" title="4.1 单向链表"></a>4.1 单向链表</h3><p>在链式描述中，数据实例的每一个元素都用一个单元或节点来描述。节点不必是数组成员，因此不是用公式来确定元素的位置。取而代之的是，每一个节点都明确包含另一个相关节点的位置信息，这个信息称为<code>链( link )</code>或<code>指针( pointer )</code>。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210409083321017.png"></p><p>一般来说，为了找到索引为theIndex的元素，需要从firstNode开始，跟踪theIndex个指针才能找到。一个线 性表的链式的每一个节点只有一个链，这种结构称为<code>单向链表( singly linkedlist)</code>。链表从左到右，每一个节点(最后一个节点除外)都链接着下一个节点，最后一个节点的链域值为NULL。这样的结构也称为<code>链条( chain )</code>。</p><p>因此，定义数据类型如下：</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//定义节点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LINKNODE<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向任何数据指针 （数据域）</span>    <span class="token keyword">struct</span> LINKNODE <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向下一个节点 （指针域）</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> LinkNode<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义链表</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> LINKLIST<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    LinkNode <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义头结点</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义链表长度</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> LinKList<span class="token punctuation">;</span></code></pre><p><code>初始化</code>：首先需要初始化链表，对于一个链表而言，只需初始化头结点的指针域和数据域。</p><pre class=" language-c"><code class="language-c">LinKList <span class="token operator">*</span><span class="token function">Init_LinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    LinKList <span class="token operator">*</span>list <span class="token operator">=</span> <span class="token punctuation">(</span>LinKList <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinKList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//申请内存存放链表</span>    list<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    list<span class="token operator">-></span>head <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//申请内存存放头结点</span>    list<span class="token operator">-></span>head<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//头结点的数据域</span>    list<span class="token operator">-></span>head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//头结点的指针域</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>插入元素</code>: 将要插入的元素与表List、位置Pos和数据指针Data一起传入。这个 Insert_LinkList（）函数将一个元索插人到由 Pos所指示的位置之后。它意味着插入操作如何实现并没有完全确定的规则。很有可能将新元素插人到位置Pos处(即在位置P处当时的元索的前面),所以需要知道位置P前面的元素。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.png"></p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Insert_LinkList</span><span class="token punctuation">(</span>LinKList <span class="token operator">*</span>List<span class="token punctuation">,</span> <span class="token keyword">int</span> Pos<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>Data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> pos <span class="token operator">></span> list<span class="token operator">-></span>size<span class="token punctuation">)</span>        pos <span class="token operator">=</span> list<span class="token operator">-></span>size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建新节点</span>    LinkNode <span class="token operator">*</span>newNode <span class="token operator">=</span> <span class="token punctuation">(</span>LinkNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找节点（即找到Pos-1位置）</span>    LinkNode <span class="token operator">*</span>pCurrent <span class="token operator">=</span> list<span class="token operator">-></span>head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//辅助指针</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        pCurrent <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//新节点入链表</span>    newNode<span class="token operator">-></span>next <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>    pCurrent<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    list<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>删除元素</code>: 通过位置删除表List中的某个元素X。需要获取元素X的位置，与插入操作相同，也许寻找出前一个元素，并且缓存前一个元素的指针域信息，将指针域信息指向Pos的下一个位置。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">RemoveByBos_linkList</span><span class="token punctuation">(</span>LinKList <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> pos <span class="token operator">>=</span> list<span class="token operator">-></span>size<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找删除的前一个节点</span>    LinkNode <span class="token operator">*</span>pCurrent <span class="token operator">=</span> list<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        pCurrent <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//缓存待删除的节点</span>    LinkNode <span class="token operator">*</span>pDel <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>    pCurrent<span class="token operator">-></span>next <span class="token operator">=</span> pDel<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//释放删除节点的内存</span>    <span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>查找元素</code>: 在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Find_LinkList</span><span class="token punctuation">(</span>LinKList <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    LinkNode <span class="token operator">*</span>pCurrent <span class="token operator">=</span> list<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pCurrent <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pCurrent<span class="token operator">-></span>data <span class="token operator">==</span> data<span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        pCurrent <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>打印输出</code>：遍历链表中的所有元素，直到最后一个元素为<code>NULL</code>,这里为了打印任何类型的数据，使用了函数指针，重定义了Print函数。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">MyPrint</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    PERSON <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>PERSON <span class="token operator">*</span><span class="token punctuation">)</span>data<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Name:%s Age:%d Score:%d\n"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>name<span class="token punctuation">,</span> p<span class="token operator">-></span>age<span class="token punctuation">,</span> p<span class="token operator">-></span>score<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Printf_LinkList</span><span class="token punctuation">(</span>LinKList <span class="token operator">*</span>list<span class="token punctuation">,</span> PRINTFLINKNODE print<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    LinkNode <span class="token operator">*</span>pCurrent <span class="token operator">=</span> list<span class="token operator">-></span>head<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pCurrent <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">print</span><span class="token punctuation">(</span>pCurrent<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        pCurrent <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><code>释放链表</code>:  清空所有元素的内存，包括链表和节点。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">FreeSpace_LinkList</span><span class="token punctuation">(</span>LinKList <span class="token operator">*</span>list<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    LinkNode <span class="token operator">*</span>pCurrent <span class="token operator">=</span> list<span class="token operator">-></span>head<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pCurrent <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//缓存下一个节点</span>        LinkNode <span class="token operator">*</span>pNext <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>pCurrent<span class="token punctuation">)</span><span class="token punctuation">;</span>        pCurrent <span class="token operator">=</span> pNext<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    list<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="4-2-双向链表"><a href="#4-2-双向链表" class="headerlink" title="4.2 双向链表"></a>4.2 双向链表</h3><p>虽然使用单链表能 100% 解决逻辑关系为 “一对一” 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 “从前往后” 找，而 “从后往前” 找并不是它的强项。本节来学习双向链表（简称双链表）。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><blockquote><p>双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要。</p></blockquote><p>从上图中可以看到，双向链表中各节点包含以下 3 部分信息：</p><ol><li>指针域：用于指向当前节点的直接前驱节点；</li><li>数据域：用于存储数据元素。</li><li>指针域：用于指向当前节点的直接后继节点；</li></ol><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210415121701683.png"></p><p>数据类型：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> NodeDataType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _DoublelinkedNode<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> _DoublelinkedNOde <span class="token operator">*</span>prior<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向直接前趋</span>    NodeDataType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> _DoublelinkedNode <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向直接后继</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> DoubLinkNode<span class="token punctuation">;</span></code></pre><p>初始化一个双向链表：</p><pre class=" language-c"><code class="language-c">DoubLinkNode <span class="token operator">*</span><span class="token function">DoubListInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    DoubLinkNode <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>DoubLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DoubLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>prior <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>data <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点</span>    DoubLinkNode <span class="token operator">*</span>list <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建新的节点并初始化</span>        DoubLinkNode <span class="token operator">*</span>body <span class="token operator">=</span> <span class="token punctuation">(</span>DoubLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DoubLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        body<span class="token operator">-></span>prior <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        body<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        body<span class="token operator">-></span>data <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//新节点与链表最后一个节点建立关系</span>        list<span class="token operator">-></span>next <span class="token operator">=</span> body<span class="token punctuation">;</span>        body<span class="token operator">-></span>prior <span class="token operator">=</span> list<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//list永远指向链表中最后一个节点</span>        list <span class="token operator">=</span> list<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong><code>双向链表添加节点</code></strong>:有三种情况，分别是头部插入、中间插入和尾部插入。</p><p>1、<code>头部插入</code>：将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。</p><p>换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：</p><ol><li>temp-&gt;next=head; head-&gt;prior=temp;</li><li>将 head 移至 temp，重新指向新的表头；</li></ol><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E5%85%A5.png" alt="双向链表头插入"></p><p>2、<code>中间位置插入</code>：同<a href="http://c.biancheng.net/view/3336.html">单链表</a>添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，</p><ol><li>新节点先与其直接后继节点建立双层逻辑关系；</li><li>新节点的直接前驱节点与之建立双层逻辑关系；</li></ol><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5.png"></p><p>3、<code>尾部插入</code>：与添加到表头是一个道理，实现过程如下：</p><ol><li><p>找到双链表中最后一个节点；</p></li><li><p>让新节点与最后一个节点进行双层逻辑关系；</p><p><img src="D:\小周的部落阁\DataStructAndAlgorithms\双向链表尾插.png"></p></li></ol><pre class=" language-c"><code class="language-c">DoubLinkNode <span class="token operator">*</span><span class="token function">InsertList</span><span class="token punctuation">(</span>DoubLinkNode <span class="token operator">*</span>list<span class="token punctuation">,</span> NodeDataType data<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    DoubLinkNode <span class="token operator">*</span>NewNode <span class="token operator">=</span> <span class="token punctuation">(</span>DoubLinkNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DoubLinkNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    NewNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    NewNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    NewNode<span class="token operator">-></span>prior <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入到链表头，要特殊考虑</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        NewNode<span class="token operator">-></span>next <span class="token operator">=</span> list<span class="token punctuation">;</span>        list<span class="token operator">-></span>prior <span class="token operator">=</span> NewNode<span class="token punctuation">;</span>        list <span class="token operator">=</span> NewNode<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//插入链表中</span>    <span class="token keyword">else</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        DoubLinkNode <span class="token operator">*</span>pCurrent <span class="token operator">=</span> list<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//辅助指针，找到插入位置的前一个节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            pCurrent <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pCurrent<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//说明插入点是尾部</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            pCurrent<span class="token operator">-></span>next <span class="token operator">=</span> NewNode<span class="token punctuation">;</span>            NewNode<span class="token operator">-></span>prior <span class="token operator">=</span> pCurrent<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token comment" spellcheck="true">//说明插入点是中间</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            pCurrent<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> NewNode<span class="token punctuation">;</span>            NewNode<span class="token operator">-></span>next <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>            pCurrent<span class="token operator">-></span>next <span class="token operator">=</span> NewNode<span class="token punctuation">;</span>            NewNode<span class="token operator">-></span>prior <span class="token operator">=</span> pCurrent<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong><code>双向链表删除节点</code></strong>:双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.png"></p><pre class=" language-c"><code class="language-c">DoubLinkNode <span class="token operator">*</span><span class="token function">DeleteNodeByData</span><span class="token punctuation">(</span>DoubLinkNode <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    DoubLinkNode <span class="token operator">*</span>pCurrent <span class="token operator">=</span> list<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pCurrent<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pCurrent<span class="token operator">-></span>data <span class="token operator">==</span> data<span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            pCurrent<span class="token operator">-></span>next<span class="token operator">-></span>prior <span class="token operator">=</span> pCurrent<span class="token operator">-></span>prior<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//pCurrent->prior->next = pCurrent->next;</span>            <span class="token function">free</span><span class="token punctuation">(</span>pCurrent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> list<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        pCurrent <span class="token operator">=</span> pCurrent<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"tThis list doesn't have this element\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong><code>双向链表查找节点</code></strong>:通常，双向链表同单链表一样，都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</p><pre class=" language-c"><code class="language-c">NodeDataType <span class="token function">selectElem</span><span class="token punctuation">(</span>DoubLinkNode <span class="token operator">*</span>list<span class="token punctuation">,</span> NodeDataType elem<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//新建一个指针t，初始化为头指针 head</span>    DoubLinkNode <span class="token operator">*</span>t <span class="token operator">=</span> list<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-></span>data <span class="token operator">==</span> elem<span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>        t <span class="token operator">=</span> t<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//程序执行至此处，表示查找失败</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong><code>双向链表更改节点</code></strong>:更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值</span>DoubLinkNode <span class="token operator">*</span><span class="token function">amendElem</span><span class="token punctuation">(</span>DoubLinkNode <span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> newElem<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    DoubLinkNode <span class="token operator">*</span>temp <span class="token operator">=</span> list<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历到被删除结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    temp<span class="token operator">-></span>data <span class="token operator">=</span> newElem<span class="token punctuation">;</span>    <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="4-3-经典算法题——约瑟夫环"><a href="#4-3-经典算法题——约瑟夫环" class="headerlink" title="4.3 经典算法题——约瑟夫环"></a>4.3 经典算法题——约瑟夫环</h3><p>约瑟夫环问题，是一个经典的循环链表问题，题意是：已知 n 个人（分别用编号 1，2，3，…，n 表示）围坐在一张圆桌周围，从编号为 k 的人开始顺时针报数，数到 m 的那个人出列；他的下一个人又从 1 开始，还是顺时针开始报数，数到 m 的那个人又出列；依次重复下去，直到圆桌上剩余一个人。</p><p>如图 所示，假设此时圆周周围有 5 个人，要求从编号为 3 的人开始顺时针数数，数到 2 的那个人出列：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF.png"></p><p>出列顺序依次为：</p><ul><li>编号为 3 的人开始数 1，然后 4 数 2，所以 4 先出列；</li><li>4 出列后，从 5 开始数 1，1 数 2，所以 1 出列；</li><li>1 出列后，从 2 开始数 1，3 数 2，所以 3 出列；</li><li>3 出列后，从 5 开始数 1，2 数 2，所以 2 出列；</li><li>最后只剩下 5 自己，所以 5 胜出。</li></ul><blockquote><p>可能用链表的方法去模拟这个过程，N个人看作是N个链表节点，节点1指向节点2，节点2指向节点3，……，节点N-1指向节点N，节点N指向节点1，这样就形成了一个环。然后从节点1开始1、2、3……往下报数，每报到M，就把那个节点从环上删除。下一个节点接着从1开始报数。最终链表仅剩一个节点。它就是最终的胜利者。</p><p>缺点：要模拟整个游戏过程，时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> number<span class="token punctuation">;</span>    <span class="token keyword">struct</span> node <span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>person<span class="token punctuation">;</span>person <span class="token operator">*</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    person <span class="token operator">*</span> head<span class="token operator">=</span><span class="token punctuation">(</span>person<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>number<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    head<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    person <span class="token operator">*</span> cyclic<span class="token operator">=</span>head<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        person <span class="token operator">*</span> body<span class="token operator">=</span><span class="token punctuation">(</span>person<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        body<span class="token operator">-></span>number<span class="token operator">=</span>i<span class="token punctuation">;</span>        body<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>         cyclic<span class="token operator">-></span>next<span class="token operator">=</span>body<span class="token punctuation">;</span>        cyclic<span class="token operator">=</span>cyclic<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    cyclic<span class="token operator">-></span>next<span class="token operator">=</span>head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//首尾相连</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">findAndKillK</span><span class="token punctuation">(</span>person <span class="token operator">*</span> head<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">,</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     person <span class="token operator">*</span> tail<span class="token operator">=</span>head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找到链表第一个结点的上一个结点，为删除操作做准备</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tail<span class="token operator">-></span>next<span class="token operator">!=</span>head<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        tail<span class="token operator">=</span>tail<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    person <span class="token operator">*</span> p<span class="token operator">=</span>head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找到编号为k的人</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>number<span class="token operator">!=</span>k<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        tail<span class="token operator">=</span>p<span class="token punctuation">;</span>        p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从编号为k的人开始，只有符合p->next==p时，说明链表中除了p结点，所有编号都出列了，</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>next<span class="token operator">!=</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            tail<span class="token operator">=</span>p<span class="token punctuation">;</span>            p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        tail<span class="token operator">-></span>next<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从链表上将p结点摘下来</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"出列人的编号为:%d\n"</span><span class="token punctuation">,</span>p<span class="token operator">-></span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">=</span>tail<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续使用p指针指向出列编号的下一个编号，游戏继续</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"出列人的编号为:%d\n"</span><span class="token punctuation">,</span>p<span class="token operator">-></span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入圆桌上的人数n:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    person <span class="token operator">*</span> head<span class="token operator">=</span><span class="token function">initLink</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"从第k人开始报数(k>1且k&lt;%d)："</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数到m的人出列："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">findAndKillK</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> k<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h2 id="第五章-栈和队列"><a href="#第五章-栈和队列" class="headerlink" title="第五章 栈和队列"></a>第五章 栈和队列</h2><h3 id="4-1-栈"><a href="#4-1-栈" class="headerlink" title="4.1 栈"></a>4.1 栈</h3><p>同顺序表和链表一样，栈也是用来存储逻辑关系为 “一对一” 数据的线性存储结构，如图所示。</p><p><img src="D:\小周的部落阁\DataStructAndAlgorithms\栈png.png"><br>从图看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 “存” 和 “取” 的过程有特殊的要求：</p><ol><li><strong>栈只能从表的一端存取数据，另一端是封闭的；</strong></li><li><strong>在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据”先进后出”的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。</strong></li></ol><p>因此，即栈是一种只能从表的一端存取数据且遵循 <strong>“先进后出”</strong> 原则的线性存储结构。</p><p>栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图中的栈底元素为元素 1。<br><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E6%A0%881.gif"></p><h3 id="4-2-进栈和出栈"><a href="#4-2-进栈和出栈" class="headerlink" title="4.2 进栈和出栈"></a>4.2 进栈和出栈</h3><p>基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：</p><ul><li>向栈中添加元素，此过程被称为”进栈”（入栈或压栈）；</li><li>从栈中提取出指定元素，此过程被称为”出栈”（或弹栈）；</li></ul><p>栈是一种 “特殊” 的线性存储结构，因此栈的具体实现有以下两种方式：</p><p>顺序栈：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//栈的数据结构</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> dataType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _LinearStack<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    dataType arr<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> LinearStack<span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//初始化一个栈：</span>LinearStack <span class="token operator">*</span><span class="token function">StackInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    LinearStack <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token punctuation">(</span>LinearStack <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinearStack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_SIZE<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        stack<span class="token operator">-></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    stack<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> stack<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//入栈</span>LinearStack <span class="token operator">*</span><span class="token function">PushStack</span><span class="token punctuation">(</span>LinearStack <span class="token operator">*</span>stack<span class="token punctuation">,</span> dataType data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    stack<span class="token operator">-></span>arr<span class="token punctuation">[</span>stack<span class="token operator">-></span>size<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数据:%d压入栈，位置为:%d \n"</span><span class="token punctuation">,</span> stack<span class="token operator">-></span>arr<span class="token punctuation">[</span>stack<span class="token operator">-></span>size<span class="token punctuation">]</span><span class="token punctuation">,</span> stack<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> stack<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出栈</span>LinearStack <span class="token operator">*</span><span class="token function">PopStack</span><span class="token punctuation">(</span>LinearStack <span class="token operator">*</span>stack<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数据:%d出栈"</span><span class="token punctuation">,</span> stack<span class="token operator">-></span>arr<span class="token punctuation">[</span>stack<span class="token operator">-></span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    stack<span class="token operator">-></span>arr<span class="token punctuation">[</span>stack<span class="token operator">-></span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    stack<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"剩余栈长为：%d \n"</span><span class="token punctuation">,</span> stack<span class="token operator">-></span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> stack<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="4-3-队列"><a href="#4-3-队列" class="headerlink" title="4.3 队列"></a>4.3 队列</h3><p>与栈结构不同的是，队列的两端都”开口”，要求数据只能从一端进，从另一端出，如图所示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E9%98%9F%E5%88%97.gif"></p><blockquote><p>通常，称进数据的一端为 “队尾”，出数据的一端为 “队头”，数据元素进队列的过程称为 “入队”，出队列的过程称为 “出队”。</p><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p></blockquote><h3 id="4-4-入队和出队"><a href="#4-4-入队和出队" class="headerlink" title="4.4 入队和出队"></a>4.4 入队和出队</h3><p>由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> datatype<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _Queue<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    datatype arr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> Queue<span class="token punctuation">;</span>Queue <span class="token operator">*</span><span class="token function">QueueInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Queue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token punctuation">(</span>Queue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        queue<span class="token operator">-></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    queue<span class="token operator">-></span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">PushQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>queue<span class="token punctuation">,</span> datatype data<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> queue<span class="token operator">-></span>size <span class="token operator">==</span> MAX<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    queue<span class="token operator">-></span>arr<span class="token punctuation">[</span>queue<span class="token operator">-></span>size<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>    queue<span class="token operator">-></span>size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">PopQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> queue<span class="token operator">-></span>size <span class="token operator">==</span> MAX<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queue<span class="token operator">-></span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        queue<span class="token operator">-></span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> queue<span class="token operator">-></span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    queue<span class="token operator">-></span>size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>datatype <span class="token function">BackTopQueue</span><span class="token punctuation">(</span>Queue <span class="token operator">*</span>queue<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> queue<span class="token operator">-></span>size <span class="token operator">==</span> MAX<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> queue<span class="token operator">-></span>arr<span class="token punctuation">[</span>queue<span class="token operator">-></span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="4-5-栈和队列的应用"><a href="#4-5-栈和队列的应用" class="headerlink" title="4.5 栈和队列的应用"></a>4.5 栈和队列的应用</h3><p>基于栈结构对数据存取采用 “先进后出” 原则的特点，它可以用于实现很多功能。</p><p>例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：</p><ul><li>重新搜索找到页面 A；</li><li>使用浏览器的”回退”功能。浏览器会先回退到页面 B，而后再回退到页面 A。</li></ul><p>浏览器 “回退” 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。</p><p>不仅如此，栈存储结构还可以帮我们检测代码中的括号匹配问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。</p><p>同时，栈结构还可以实现数值的进制转换功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。</p><p>以上也仅是栈应用领域的冰山一角，这里不再过多举例。在后续章节的学习中，我们会大量使用到栈结构。接下来，我们学习如何实现顺序栈和链栈，以及对栈中元素进行入栈和出栈的操作。</p><h2 id="第六章-串"><a href="#第六章-串" class="headerlink" title="第六章 串"></a>第六章 串</h2><p>数据结构中，字符串要单独用一种存储结构来存储，称为串存储结构。这里的串指的就是字符串。严格意义上讲，串存储结构也是一种线性存储结构，因为字符串中的字符之间也具有”一对一”的逻辑关系。只不过，与之前所学的线性存储结构不同，串结构只用于存储字符类型的数据。</p><p>无论学习哪种编程语言，操作最多的总是字符串。数据结构中，根据串中存储字符的数量及特点，对一些特殊的串进行了命名，比如说：</p><ul><li>空串：存储 0 个字符的串，例如 S = “”（双引号紧挨着）；</li><li>空格串：只包含空格字符的串，例如 S = “   “（双引号包含 5 个空格）；</li><li>子串和主串：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a = “shujujiegou”，b = “shuju”，由于 a 中也包含 “shuju”，因此串 a 和串 b 是主串和子串的关系；</li></ul><p>另外，对于具有主串和子串关系的两个串，通常会让你用算法找到子串在主串的位置。子串在主串中的位置，指的是子串首个字符在主串中的位置。</p><p>例如，串 a = “shujujiegou”，串 b = “jiegou”，通过观察，可以判断 a 和 b 是主串和子串的关系，同时子串 b 位于主串 a 中第 6 的位置，因为在串 a 中，串 b 首字符 ‘j’ 的位置是 6。</p><h3 id="6-1-串的定长顺序存储"><a href="#6-1-串的定长顺序存储" class="headerlink" title="6.1 串的定长顺序存储"></a>6.1 串的定长顺序存储</h3><blockquote><p>串的定长顺序存储结构，可以简单地理解为采用 “固定长度的顺序存储结构” 来存储字符串，因此限定了其底层实现只能使用静态数组。</p></blockquote><p>使用定长顺序存储结构存储字符串时，需结合目标字符串的长度，预先申请足够大的内存空间。例如，采用定长顺序存储结构存储 “<a href="http://www.codezhou.club&quot;,通过目测得知此字符串长度为/">www.codezhou.club&quot;，通过目测得知此字符串长度为</a> 17，因此我们申请的数组空间长度至少为 18（最后一位存储字符串的结束标志 ‘\0’），用 C 语言表示为：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">=</span> “www<span class="token punctuation">.</span>codezhou<span class="token punctuation">.</span>club"<span class="token punctuation">;</span></code></pre><h3 id="6-2-串的堆分配存储"><a href="#6-2-串的堆分配存储" class="headerlink" title="6.2 串的堆分配存储"></a>6.2 串的堆分配存储</h3><p>串的堆分配存储其具体实现方式是采用动态数组存储字符串。通常，编程语言会将程序占有的内存空间分成多个不同的区域，程序包含的数据会被分门别类并存储到对应的区域。拿 C 语言来说，程序会将内存分为 4 个区域，分别为堆区、栈区、数据区和代码区。</p><p>与其他区域不同，堆区的内存空间需要程序员手动使用 malloc 函数申请，并且在不用后要手动通过 free 函数将其释放。</p><p>C 语言中使用 malloc 函数最多的场景是给数组分配空间，这类数组称为动态数组。例如：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此行代码创建了一个动态数组 a，通过使用 malloc 申请了 5 个 char 类型大小的堆存储空间。</p><p>==动态数组相比普通数组（静态数组）的优势是长度可变，换句话说，根据需要动态数组可额外申请更多的堆空间（使用 relloc 函数）：==</p><pre class=" language-c"><code class="language-c">a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通过使用这行代码，之前具有 5 个 char 型存储空间的动态数组，其容量扩大为可存储 10 个 char 型数据。</p><p>完整展示如下：</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>a1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>a2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    a1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> <span class="token string">"http://www"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将字符串"http://www"复制给a1</span>    a2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>a2<span class="token punctuation">,</span> <span class="token string">"codezhou.club"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> lengthA1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a1串的长度</span>    <span class="token keyword">int</span> lengthA2 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//a2串的长度</span>    <span class="token comment" spellcheck="true">//尝试将合并的串存储在 a1 中，如果 a1 空间不够，则用realloc动态申请</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lengthA1 <span class="token operator">&lt;</span> lengthA1 <span class="token operator">+</span> lengthA2<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        a1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> <span class="token punctuation">(</span>lengthA1 <span class="token operator">+</span> lengthA2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//合并两个串到 a1 中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> lengthA1<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lengthA1 <span class="token operator">+</span> lengthA2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        a1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a2<span class="token punctuation">[</span>i <span class="token operator">-</span> lengthA1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//串的末尾要添加 \0，避免出错</span>    a1<span class="token punctuation">[</span>lengthA1 <span class="token operator">+</span> lengthA2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//用完动态数组要立即释放</span>    <span class="token function">free</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="6-3-BF算法"><a href="#6-3-BF算法" class="headerlink" title="6.3 BF算法"></a>6.3 BF算法</h3><p>暴力(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法。</p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/20210507125343.png" style="zoom:80%;" /><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span> String S<span class="token punctuation">,</span> String T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// i 表示主串 S 中当前位置下标</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// j 表示子串 T 中当前位置下标</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> i <span class="token operator">&lt;=</span> S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// i 或 j 其中一个到达尾部则终止搜索</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 若相等则继续进行下一个元素匹配</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 若匹配失败则 j 回溯到第一个元素重新匹配</span>            i <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 将 i 重新回溯到上次匹配首位的下一个元素</span>            j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> j <span class="token operator">></span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>BF算法时间复杂度:该算法最理想的时间复杂度 <code>O(n)</code>，n 表示串 A 的长度，即第一次匹配就成功。BF 算法最坏情况的时间复杂度为 <code>O(n*m)</code>，n 为串 A 的长度，m 为串 B 的长度。例如，串 B 为 “0000000001”，而串 A 为 “01”，这种情况下，两个串每次匹配，都必须匹配至串 A 的最末尾才能判断匹配失败，因此运行了 n*m 次。</p><p>BF 算法的实现过程很 “无脑”，不包含任何技巧，在对数据量大的串进行模式匹配时，算法的效率很低。</p><h3 id="6-4-KMP算法"><a href="#6-4-KMP算法" class="headerlink" title="6.4 KMP算法"></a>6.4 KMP算法</h3><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>Knuth-Morris-Pratt<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">字符串查找算法</a><strong>（简称为</strong>KMP算法</strong>）可在一个<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a><code>S</code>内查找一个词<code>W</code>的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重新检查先前匹配的<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6">字符</a>。</p><p>这个算法由<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3">高德纳</a>和<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B2%83%E6%81%A9%C2%B7%E6%99%AE%E6%8B%89%E7%89%B9&action=edit&redlink=1">沃恩·普拉特</a>在1974年构思，同年<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7H%C2%B7%E8%8E%AB%E9%87%8C%E6%96%AF&action=edit&redlink=1">詹姆斯·H·莫里斯</a>也独立地设计出该算法，最终三人于1977年联合发表。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像处理（DIP）</title>
      <link href="/2020/04/26/digitalimageprocessing/"/>
      <url>/2020/04/26/digitalimageprocessing/</url>
      
        <content type="html"><![CDATA[<h1 id="数字图像处理（基于Python-Opencv）"><a href="#数字图像处理（基于Python-Opencv）" class="headerlink" title="数字图像处理（基于Python-Opencv）"></a>数字图像处理（基于Python-Opencv）</h1><h2 id="第一章-图像基础"><a href="#第一章-图像基础" class="headerlink" title="第一章 图像基础"></a>第一章 图像基础</h2><h3 id="1-1-图像的基本概念"><a href="#1-1-图像的基本概念" class="headerlink" title="1.1 图像的基本概念"></a>1.1 图像的基本概念</h3><p><strong>（1）图像的颜色</strong></p><p>色度学理论认为，任何颜色可由红、绿、蓝三种基本颜色混合得到。n图像可用红、绿、蓝三原色来表示。</p><p>$$ f(x,y,z) = {fred(x,y,z),fgreen(x,y,z),fbule(x,y,z)}$$</p><p><strong>（2）图像的表示</strong></p><p>一般来说，图像是一个标准的矩形，有着宽度（width）和高度（height）。而矩阵有着行（row）和列（column），矩阵的操作在数学和计算机中的处理都很常见且成熟，于是很自然的就把图像作为一个矩阵，把对图像的操作转换成对矩阵的操作。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E7%9F%A9%E9%98%B5.png"></p><p>$f_{mn}$代表该象素彩色或灰度值脚码代表象素的坐标位置:</p><p>使用opencv获取并修改像素值:读取一副图像，根据像素的行和列的坐标获取它的像素值，对于RGB图像而言，返回RGB的值，对于灰度图则返回灰度值。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpyimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'test.jpg'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#读入图片</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出图片的大小，返回图像的像素数目</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出图片的形状，返回值是一个包含行数，列数，通道数的元组</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#返回图像的数据类型</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E5%AF%B9%E5%BA%94.png"></p><p><strong>图像空间分辨率</strong> :指图像数字化的空间精细程度。</p><p><strong>灰度级分辨率</strong>:即颜色深度，表示每一像素的颜色值所占的二进制位数。颜色深度越大则能表示的颜色数目越多。</p><h3 id="1-2-图像的存储格式"><a href="#1-2-图像的存储格式" class="headerlink" title="1.2 图像的存储格式"></a>1.2 图像的存储格式</h3><p>彩色图像是指每个像素的信息由R G B三原色构成的图像，其中R G B是由不同的灰度级来描述的:</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210429205546906.png"></p><p>(1) 颜色表红、绿、蓝分量值不全相等。<br>        (2) 像素值是图像颜色表的索引地址。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210429205914771.png"></p><p>(1)每一像素由RGB三个分量组成。</p><p>(2)每个分量各占8位，取值范围为0~255，每个像素24位。</p><p>按照颜色深度分类,常用图像文件:</p><ul><li>黑白图像</li><li>8位索引图像</li><li>24位真彩色图像</li></ul><h2 id="第二章-基础操作"><a href="#第二章-基础操作" class="headerlink" title="第二章 基础操作"></a>第二章 基础操作</h2><h3 id="2-1-图像的算数运算"><a href="#2-1-图像的算数运算" class="headerlink" title="2.1 图像的算数运算"></a>2.1 图像的算数运算</h3><p><strong>1、图像加法</strong>：使用cv2.add()将两幅图像进行加法运算，也可以直接使用numpy，res=img1+img2。两幅图像的大小，类型必须一致，或者第二个图像可以是一个简单的标量值。openCV的加法是一种饱和操作，而numpy的加法是一种模操作。</p><pre class=" language-python"><code class="language-python">x<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">250</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#250+10=260>=255</span><span class="token comment" spellcheck="true">#结果为[[255]]</span><span class="token keyword">print</span> <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#250+10=260%255=4</span><span class="token comment" spellcheck="true">#结果为[4]</span></code></pre><p><em>OpenCV的结果会更好，尽量使用OpenCV中的函数</em></p><p><strong>2、图像混合</strong>：这也是加法，不同的是两幅图像的权重不同，这会给人一种混合或者透明的感觉。图像混合的计算公式如下：<br>$$<br>g(x) = (1−\alpha)f_0 (x)+\alpha f_1 (x)<br>$$<br>通过修改$\alpha$的值（0–&gt;1）,可以实现很酷的混合。例：将两幅图像混合，第一幅权重为0.7.第二幅权重为0.3。函数cv2.addWeighed()可以按下面的公式对图片进行混合。$dst = \alpha·img1 + \beta·img2+\gamma$。这里γ的取值为0.</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npimg1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'test0.jpg'</span><span class="token punctuation">)</span>img2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'test1.png'</span><span class="token punctuation">)</span>dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img1<span class="token punctuation">,</span><span class="token number">0.7</span><span class="token punctuation">,</span>img2<span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'dst'</span><span class="token punctuation">,</span>dst<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/1111111.png"></p><h3 id="2-2-几何变换"><a href="#2-2-几何变换" class="headerlink" title="2.2 几何变换"></a>2.2 几何变换</h3><p><strong>1、扩展缩放</strong>：只是改变图像的尺寸大小，cv2.resize()可以实现这个功能。在缩放时推荐cv2.INTER_AREA，在拓展时推荐cv2.INTER_CUBIC（慢）和cv2.INTER_LINEAR。默认情况下所有改变图像尺寸大小的操作使用的是<em>插值法</em>都是cv2.INTER_LINEAR。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'test.jpg'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#下面的None本应该是输出图像的尺寸，但是因为后面我们设置了缩放因子，所以，这里为None</span>res <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img<span class="token punctuation">,</span>None<span class="token punctuation">,</span>fx<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>fy<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>interpolation<span class="token operator">=</span>cv2<span class="token punctuation">.</span>INTER_CUBIC<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#or</span><span class="token comment" spellcheck="true">#这里直接设置输出图像的尺寸，所以不用设置缩放因子</span>height <span class="token punctuation">,</span> width <span class="token operator">=</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>res <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>width<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span>interpolation<span class="token operator">=</span>cv2<span class="token punctuation">.</span>INTER_CUBIC<span class="token punctuation">)</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'res'</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>    cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>    <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span> <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>2、平移</strong>：如果想要沿（x，y）方向移动，移动的距离为（t<sub>x</sub>,t<sub>y</sub>）可以以下面方式构建移动矩阵。<br>$$<br>\left[ \begin{matrix} 1 &amp; 0 &amp; t_x\ 0 &amp; 1 &amp; t_y \end{matrix} \right]<br>$$</p><p>可以使用Numpy数组构建矩阵，数据类型是np.float32，然后传给函数cv2.warpAffine()，函数cv2.warpAffine() 的第三个参数的是输出图像的大小，它的格式应该是图像的（宽，高）。应该记住的是图像的宽对应的是列数，高对应的是行数。</p><pre class=" language-python"><code class="language-python">img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'./test1.jpg'</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>IMREAD_COLOR<span class="token punctuation">)</span> tx <span class="token operator">=</span> <span class="token number">20</span>ty <span class="token operator">=</span> <span class="token number">20</span> affine_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>tx<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>ty<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> res <span class="token operator">=</span> cv2<span class="token punctuation">.</span>warpAffine<span class="token punctuation">(</span>img1<span class="token punctuation">,</span>affine_arr<span class="token punctuation">,</span><span class="token punctuation">(</span>img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img1<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'res'</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210430123037189.png"></p><p><strong>3、旋转</strong>：对一个图像旋转角度θ，需要使用下面的旋转矩阵。<br>$$<br>\left[ \begin{matrix} cos\theta &amp; -sin\theta\ sin\theta &amp; cos\theta \end{matrix} \right]<br>$$<br>但OpenCVC允许在任意地方进行旋转，所以矩阵应该为:<br>$$<br>\left[ \begin{matrix} \alpha &amp; \beta &amp; (1-\alpha)·center_x-\beta·center_y\ -\beta &amp; \alpha &amp; \beta·center_x+(1-\alpha)·center_y\end{matrix} \right]<br>$$<br>其中α = scale · cos θ，为构建旋转矩阵，OpenCV提供了一个函数cv2.getRotationMatrix2D。</p><pre class=" language-python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'test1.jpg'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>rows<span class="token punctuation">,</span>cols<span class="token operator">=</span>img<span class="token punctuation">.</span>shape<span class="token comment" spellcheck="true"># 这里的第一个参数为旋转中心，第二个为旋转角度，第三个为旋转后的缩放因子</span><span class="token comment" spellcheck="true"># 可以通过设置旋转中心，缩放因子，以及窗口大小来防止旋转后超出边界的问题</span>m<span class="token operator">=</span>cv2<span class="token punctuation">.</span>getRotationMatrix2D<span class="token punctuation">(</span><span class="token punctuation">(</span>cols<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>rows<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">)</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>warpAffine<span class="token punctuation">(</span>img<span class="token punctuation">,</span>m<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>cols<span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span>rows<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'dst'</span><span class="token punctuation">,</span>dst<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/22222.png" alt="22222"></p><p><strong>4、仿射变换</strong>：在仿射变换中，原图中所有平行线在结果图像中同样平行。为创建这个矩阵，需要从原图像中找到三个点以及他们在输出图像中的位置，然后cv2.getAffineTransForm()会创建一个2X3的矩阵。最后这个矩阵会被传给函数cv2.warpAffine()</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'test1.jpg'</span><span class="token punctuation">)</span>rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> ch <span class="token operator">=</span> img<span class="token punctuation">.</span>shape pts1 <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>cols <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> rows <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>pts2 <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span>cols <span class="token operator">*</span> <span class="token number">0.2</span><span class="token punctuation">,</span> rows <span class="token operator">*</span> <span class="token number">0.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>cols <span class="token operator">*</span> <span class="token number">0.9</span><span class="token punctuation">,</span> rows <span class="token operator">*</span> <span class="token number">0.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>cols <span class="token operator">*</span> <span class="token number">0.1</span><span class="token punctuation">,</span> rows <span class="token operator">*</span> <span class="token number">0.9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> M <span class="token operator">=</span> cv2<span class="token punctuation">.</span>getAffineTransform<span class="token punctuation">(</span>pts1<span class="token punctuation">,</span> pts2<span class="token punctuation">)</span>dst <span class="token operator">=</span> cv2<span class="token punctuation">.</span>warpAffine<span class="token punctuation">(</span>img<span class="token punctuation">,</span> M<span class="token punctuation">,</span> <span class="token punctuation">(</span>cols<span class="token punctuation">,</span> rows<span class="token punctuation">)</span><span class="token punctuation">)</span> cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">,</span> dst<span class="token punctuation">)</span>k <span class="token operator">=</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">if</span> k <span class="token operator">==</span> ord<span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'Rachel1.jpg'</span><span class="token punctuation">,</span> dst<span class="token punctuation">)</span>    cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20210430130001963.png"></p><p><strong>5、透视变换</strong>：对于视角变换，我们需要一个3x3变换矩阵。在变换前后直线还是直线。需要在原图上找到4个点，以及他们在输出图上对应的位置，这四个点中任意三个都不能共线，可以有函数cv2.getPerspectiveTransform()构建，然后这个矩阵传给函数cv2.warpPerspective()</p><p><img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20210430130315466.png" alt="image-20210430130315466"></p><h3 id="2-3-ROI和泛洪填充"><a href="#2-3-ROI和泛洪填充" class="headerlink" title="2.3 ROI和泛洪填充"></a>2.3 ROI和泛洪填充</h3><p>图像ROI（region of intrest:感兴趣区域）的提取往往是图像处理中的第一步，而且也是非常关键的一步，ROI区域的提取能够在消除一些噪声的同时减少后续图像处理的数据量，是非常常用的方法。</p><p>  <strong>ROI有什么用？</strong></p><p>  ROI属于IVE技术的一种，IVE指的是Intelligent video encoding, 即智能视频编码， IVE技术可以根据客户要求对视频进行智能编码，并在不损失图像质量的前提下，优化视频编码性能，最终降低网络带宽占用率和减少存储空间。</p><p>在监控画面中，有些监控区域是不需要被监控或无关紧要，例如天空，墙壁， 草地等等监控对象，普通网络监控摄像机对整个区域进行视频编码（压缩）并传输，这样就给网络带宽和视频存储带来了压力。而ROI智能视频编码技术却很好的解决了这个问题，ROI功能的摄像机可以让用户选择画面中感兴趣的区域，启用ROI功能后，重要的或者移动的区域将会进行高质量无损编码， 而对那些不移动，不被选择的区域降低其码率和图像质量，进行标准清晰度视频压缩，甚至是不传输这部分区域视频，达到节省网络带宽占用和视频存储空间。  </p><p>例如如下图所示，通过opencv提取出图片中的荷花主体。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210506213240571.png"></p><h2 id="第三章-模糊操作"><a href="#第三章-模糊操作" class="headerlink" title="第三章 模糊操作"></a>第三章 模糊操作</h2><p><strong>模糊原理：</strong>基于离散卷积，不同的卷积得到不同的卷积效果，模糊是卷积的表象。</p><p>如果使用二维数字图像Image作为我们的输入，就需使用二维卷积核Kernel，则：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image002.gif"></p><p>卷积运算由图表示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210506214718559.png"></p><h3 id="3-1-均值模糊"><a href="#3-1-均值模糊" class="headerlink" title="3.1 均值模糊"></a>3.1 均值模糊</h3><p>均值滤波是典型的线性滤波算法，模糊是卷积的一种表象，所有的滤波模板都是使卷积框覆盖区域所有像素点与模板相乘后得到的值作为中心像素的值，比如一个3 * 3的模板其实就可以如下表示：</p><p>$$<br>\frac{1}{9} \left[ \begin{matrix} 1 &amp; 1 &amp; 1\ 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 \end{matrix} \right]<br>$$</p><p>opencv中提供了cv.blur () AP可以直接均值模糊，例如：经过上述5*5的卷积核模糊变换后，效果如下：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210506220323051.png"></p><h3 id="3-2-中值模糊"><a href="#3-2-中值模糊" class="headerlink" title="3.2 中值模糊"></a>3.2 中值模糊</h3><p>中值模糊方法在去除脉冲噪声、斑点噪声（speckle noise）、椒盐噪声（salt-and-pepper noise）、图像扫描噪声的同时又能保留凸图像边缘细节。</p><p>中值滤波与均值滤波比较：</p><p>优势是，在均值滤波器中，由于噪声成分被放入平均计算中，所以输出受到了噪声的影响；而在中值滤波其中，噪声成分很难选上，所以几乎不会影响到输出。</p><p>劣势是，中值滤波花费的时间是均值滤波的5倍以上。</p><p>注意：中值滤波虽然可以克服线性滤波器所带来的图像细节模糊，但是在线、尖顶等细节多的图像不宜用中值滤波。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2.png"></p><h3 id="3-3-高斯模糊"><a href="#3-3-高斯模糊" class="headerlink" title="3.3 高斯模糊"></a>3.3 高斯模糊</h3><p>高斯模糊本质上是低通滤波器，输出图像的每个像素点是原图像上对应像素点与周围像素点的加权和，原理并不复杂。做久了卷积神经网络看这个分外亲切，就是用高斯分布（正态分布）权值矩阵与原始图像矩阵做卷积运算而已。</p><p>正态分布显然是一种可取的权重分配模式：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png"></p><p>在图形上，正态分布是一种钟形曲线，越接近中心，取值越大，越远离中心，取值越小。计算平均值的时候，我们只需要将”中心点”作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。</p><p>上面的正态分布是一维的，图像都是二维的，所以需要二维的正态分布。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%832D.png"></p><p>正态分布的密度函数叫做“高斯函数”（Gaussian function）。它的一维形式是：</p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/3-1.png" style="zoom:50%;" /><p>其中，μ是x的均值，σ是x的方差。因为计算平均值的时候，中心点就是原点，所以μ等于0。</p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/3-2.png" style="zoom:50%;" /><p>根据一维高斯函数，可以推导得到二维高斯函数：</p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/3-3.png" style="zoom:50%;" /><p>有了这个函数 ，就可以计算每个点的权重了。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> cv2img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'lena.png'</span><span class="token punctuation">)</span>img_ <span class="token operator">=</span> cv2<span class="token punctuation">.</span>GaussianBlur<span class="token punctuation">(</span>img<span class="token punctuation">,</span> ksize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sigmaX<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> sigmaY<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'Source image'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'blur image'</span><span class="token punctuation">,</span>img_<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210507094629011.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS在STM32上的应用</title>
      <link href="/2020/04/09/freertosonstm32/"/>
      <url>/2020/04/09/freertosonstm32/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeRTOS在STM32上的应用"><a href="#FreeRTOS在STM32上的应用" class="headerlink" title="FreeRTOS在STM32上的应用"></a>FreeRTOS在STM32上的应用</h1><h2 id="第一章-任务管理"><a href="#第一章-任务管理" class="headerlink" title="第一章 任务管理"></a>第一章 任务管理</h2><p>在 FreeRTOS 中，每个执行线程都被称为”任务”。在嵌入式社区中，对此并没有一个公允的术语，但更喜欢用”任务”而不是”线程”，因为从以前的经验来看，线程具有更多的特定含义。</p><h3 id="1-1-任务函数"><a href="#1-1-任务函数" class="headerlink" title="1.1 任务函数"></a>1.1 任务函数</h3><p>任务是由 C 语言函数实现的。唯一特别的只是任务的函数原型，其必须返回void，而且带有一个void 指针参数。函数原型如下：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ATaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>每个任务都是在自己权限范围内的一个小程序。其具有程序入口，通常会运行在一个死循环中，也不会退出。FreeRTOS 任务不允许以任何方式从实现函数中返回——它们绝不能有一条”return”语句，也不能执行到函数末尾。如果一个任务不再需要，可以显式地将其删除。一个任务函数可以用来创建若干个任务——创建出的任务均是独立的执行实例，拥有属于自己的栈空间，以及属于自己的自动变量(栈变量)，即任务函数本身定义的变量。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ATaskFunction</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span>pvParameters <span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 可以像普通函数一样定义变量。用这个函数创建的每个任务实例都有一个属于自己的iVarialbleExample变量。但如果iVariableExample被定义为static，这一点则不成立 – 这种情况下只存在一个变量，所有的任务实例将会共享这个变量。 */</span>    <span class="token keyword">int</span> iVariableExample <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 任务通常实现在一个死循环中。 */</span>    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 完成任务功能的代码将放在这里。 */</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 如果任务的具体实现会跳出上面的死循环，则此任务必须在函数运行完之前删除。传入NULL参数表示删除是当前任务*/</span>    <span class="token function">vTaskDelete</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="1-2-顶层任务状态"><a href="#1-2-顶层任务状态" class="headerlink" title="1.2 顶层任务状态"></a>1.2 顶层任务状态</h3><p>应用程序可以包含多个任务。如果运行应用程序的微控制器只有一个核[core]，那么在任意给定时间，实际上只会有一个任务被执行。这就意味着一个任务可以有一个或两个状态，即运行状态和非运行状态。</p><p>当某个任务处于运行态时，处理器就正在执行它的代码。当一个任务处于非运行态时，该任务进行休眠，它的所有状态都被妥善保存，以便在下一次调试器决定让它进入运行态时可以恢复执行。当任务恢复执行时，其将精确地从离开运行态时正准备执行的那一条指令开始执行。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E9%A1%B6%E5%B1%82%E4%BB%BB%E5%8A%A1.png"></p><p>FreeRTOS 的调度器是能让任务切入切出的唯一实体。任务从非运行态转移到运行态被称为”切换入或切入[switched in]”或”交换入[swapped in]”。相反，任务从运行态转移到非运行态被称为”切换出或切出[switchedout]”或”交换出[swapped out]”。</p><h3 id="1-3-创建任务"><a href="#1-3-创建任务" class="headerlink" title="1.3 创建任务"></a>1.3 创建任务</h3><p>xTaskCreate() API 函数：</p><pre class=" language-c"><code class="language-c">BaseType_t <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>        TaskFunction_t pxTaskCode<span class="token punctuation">,</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> pcName<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>    <span class="token keyword">const</span> configSTACK_DEPTH_TYPE usStackDepth<span class="token punctuation">,</span>    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">const</span> pvParameters<span class="token punctuation">,</span>    UBaseType_t uxPriority<span class="token punctuation">,</span>    TaskHandle_t <span class="token operator">*</span> <span class="token keyword">const</span> pxCreatedTask <span class="token punctuation">)</span></code></pre><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">pxTaskCode</td><td align="center">任务只是永不退出的C 函数，实现常通常是一个死循环。参数pvTaskCode 只一个指向任务的实现函数的指针(效果上仅仅是函数)。</td></tr><tr><td align="center">pcName</td><td align="center">具有描述性的任务名。这个参数不会被FreeRTOS 使用。其只是单纯地用于辅助调试。</td></tr><tr><td align="center">usStackDepth</td><td align="center">usStackDepth 值用于告诉内核为它分配多大的栈空。栈深度乘以栈宽度的结果千万不能超过一个size_t 类型变量所能表达的最大值。</td></tr><tr><td align="center">pvParameters</td><td align="center">任务函数接受一个指向void 的指针(void*)。pvParameters 的值即是传递到任务中的值。</td></tr><tr><td align="center">uxPriority</td><td align="center">指定任务执行的优先级。优先级的取值范围可以从最低优先级0 到最高优先级(configMAX_PRIORITIES – 1)。</td></tr><tr><td align="center">pxCreatedTask</td><td align="center">pxCreatedTask 用于传出任务的句柄。这个句柄将在API 调用中对该创建出来的任务进行引用，比如改变任务优先级，或者删除任务。如果应用程序中不会用到这个任务的句柄，则pxCreatedTask 可以被设为NULL。</td></tr></tbody></table><p>返回值：</p><p><code>pdTRUE</code>：表明任务创建成功。</p><p><code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code>: 由于内存堆空间不足，FreeRTOS 无法分配足够的空间来保存任务结构数据和任务栈，因此无法创建任务。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> STM32 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器视觉的算法研究</title>
      <link href="/2020/04/07/juan-ji-shen-jing-wang-luo-fen-lei-tu-pian/"/>
      <url>/2020/04/07/juan-ji-shen-jing-wang-luo-fen-lei-tu-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="机器视觉的算法研究"><a href="#机器视觉的算法研究" class="headerlink" title="机器视觉的算法研究"></a>机器视觉的算法研究</h1><p><em>本文详细解释《基于机器视觉的仿生机掌》中用到的卷积神经网络算法</em></p><p>机器视觉系统就是利用机器代替人眼作出各种测量和判断。它综合了光学、机械、电子、计算机软硬件等方面的技术，涉及到计算机、图像处理、模式识别、人工智能、信号处理、光机电一体化等多个领域。本章将介绍以手势分类为基础的机器视觉算法。运用机器视觉领域中最常见卷积神经网络来以分类三种“石头”、“剪刀”、“布”三种手势。本章的主要内容包括卷积神经网络概述、手势样本的采集及处理、搭建卷积神经网络、仿真结构及分析。</p><h2 id="1、卷积神经网络概述"><a href="#1、卷积神经网络概述" class="headerlink" title="1、卷积神经网络概述"></a>1、卷积神经网络概述</h2><p>卷积神经网络（Convolutional Neural Network, CNN）是一种前馈神经网络，对于大型图像处理有出色表现。卷积神经网络由一个或多个卷积层和顶端的全连通层组成，同时也包括关联权重和池化层（pooling layer）。卷积运算使得卷积神经网络能够利用输入数据的二维结构。在图像识别方面领域，卷积神经网络与其他深度学习结构相比能够给出更好的结果。</p><h3 id="1-1、-卷积神经网络数学模型"><a href="#1-1、-卷积神经网络数学模型" class="headerlink" title="1.1、 卷积神经网络数学模型"></a>1.1、 卷积神经网络数学模型</h3><p>卷积网络是一种专门用于处理具有已知的、网格状拓扑数据的神经网络。既然被称为“卷积神经网络”，则表示在运算过程中采用称为卷积运算(convolutions)。卷积是一种特殊的线性操作。记为卷积运算符，则卷积运算公式写作</p><p>​     <img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310111526774.png"></p><p>在实际使用中，需要对多维数据进行卷积运算，因此上式也需要根据实际情况进行扩展。例如，如果使用二维数字图像Image作为我们的输入，就需使用二维卷积核Kernel，则：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310111548796.png">)</p><p>卷积运算是可交换的，这意味着上式可以等价为：</p><p> <img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310111604623.png"></p><p>卷积运算由表示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image002.gif"></p><p>卷积操作主要利用了参数共享，稀疏交互和等变表示的重要思想，以及处理可变大小的输入改进机器学习系统。</p><p>卷积运算后，就获得了图像的特征(feature map)，若直接用该特征图像去做分类则面临巨大计算量的挑战。例如：有一张128<em>128个像素的图像，假设通过卷积运算得到了500个定义在8</em>8输入上的特征，每个特征和图像卷积会得到一个卷积特征，则一共有(128-8+1)<em>(128-8)=14641维度的卷积特征，所以每个样本会得到一个14641</em>500=732 0500维的卷积特征向量。学习一个拥有超过七百万特征输入的分类器十分不便，并且容易出现过拟合(over-fitting)。因此需要另一种操作——池化（Pooling），池化的结果可以使得特征减少，参数减少。</p><p>常见的池化方式有如下三种：</p><p><strong>1)</strong> <strong>均值池化</strong>  平均池化取某个邻域的平均值作为该区域的输出值。</p><p><strong>2)</strong> <strong>最大值池化</strong>  最大值池化则是某个邻域内的最大值作为输出值。</p><p><strong>3)</strong> <strong>概率池化</strong>  介于前两者之间，对像素按照数值大小赋予概率，再按照概率进行输出。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image004.gif"></p><h3 id="1-2、-卷积神经网络基础结构"><a href="#1-2、-卷积神经网络基础结构" class="headerlink" title="1.2、 卷积神经网络基础结构"></a>1.2、 卷积神经网络基础结构</h3><p>计算机将输入图像理解为输入若干个矩阵。卷积神经网络由卷积层、池化层、全连接层三部分构成，卷积层可以提取图像中的局部特征；池化层用来大幅降低参数量级(降维)；全连接层类似传统神经网络的部分，用来输出想要的结果。但卷积神经网络并不仅仅只有三个层级，例如下图就是由输入层、卷积层、池化层、卷积层、池化层、全连接层叠加组成，这就构成了另一类经典的卷积神经网络模型，即本课题中用以手势分类的卷积神经网络模型。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image006.gif"></p><p><strong>（1）输入层</strong></p><p>卷积神经网络用于图像识别时，输入层即为数字图像，而数字图像实际上是巨大的数字矩阵。矩阵中的每个数字对应于其像素的亮度。在RGB模型中，彩色图像由三个矩阵组成，分别对应三个颜色通道——红，绿，蓝。而在黑白图像中，我们只需要一个矩阵。矩阵中的每个数字的取值区间都是0到255。</p><p><strong>（2）卷积层——提取特征</strong></p><p>这一层的主要部分就是进行卷积操作，前面已经介绍了卷积的概念，卷积层实际上就是实现了这个卷积的计算过程，卷积将输入矩阵与第二个矩阵（卷积核）进行卷积运算。卷积过程如下所示。首先，将卷积核叠加在图像数组的左上部。接下来，所对应图片的子部分与卷积核进行卷积运算。也就是说，将卷积核与图像的左上部元素相乘，依此类推。然后，将这些结果相加来生成一个值。接着，将卷积核在图像上移动一段距离（称为步幅），并重复该过程。此过程的输出是一个具有与图像数组不同维数的新矩阵，例如，有一个常见的3*3卷积核(拉普拉斯算子)： </p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310111648024.png"></p><p>经过卷积运算后，可以明显看出，图像的边缘特征已经被提取出来。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image008.gif"></p><p><strong>（3）池化层——数据降维</strong></p><p>池化过程的作用是降低数据的维度。在经过卷积运算之后的图中，对1000*1000像素的图片进行池化，池化窗口为10×10，最终将其降维成为一个100×100大小的特征图。之所以需要进行池化，是因为即使做完了卷积运算，图像仍然很大，所以为了降低数据维度，就需要进行池化。池化层相比卷积层可以更有效的降低数据维度，这么做不但可以大大减少运算量，还可以有效的避免过拟合[20]。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image010.gif"></p><p><strong>（4）全连接层</strong></p><p>在CNN结构中，经过最后一个卷积层和最后一池化层后。输出结果仍然是图像。怎么能将图像向量呢？池化后输出的是20个12<em>12的图像，怎么变成1</em>100的向量？这就需要全连接层。全连接层的输出是所有输入值与对应的权值乘积的和。全连接层的输出就是12<em>12</em>20个输入值与其权值乘积的和。这样就把一张图高度浓缩成一个数了。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image012.gif"></p><h2 id="2、-手势样本采集及处理"><a href="#2、-手势样本采集及处理" class="headerlink" title="2、 手势样本采集及处理"></a>2、 手势样本采集及处理</h2><p>在深度学习框架中，最难得的就是样本数据。本次实验需要最少两万张100*100像素的各类手势图片，显然采取直接拍摄的方式是难以完成如此大量的工作。所以本组采取使用自动化脚本程序从视频自动截取各类手势图片。具体操作为，先开启摄像头并创建一个摄像头显示窗口，每隔100ms从视频中截取一张图片保存到本地文件夹，照片命名为imageX.jpg ，其中X表示序号。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image014.jpg"></p><p>课题中所采集的四类样本一共为20000张图彩色图片，每类图片约5000张，分别将“石头”“剪刀”“布”“干扰手势”四种图片保存到rock、scissors、paper、others四个文件夹中。一个具有良好识别率的系统往往离不开优秀的前期处理，但我们追求的不是一个依赖于前期良好处理的识别系统，为此我们做了灰度处理和图像二值化处理。以一张“布”手势展示处理过程。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image016.gif"></p><p>其中灰度处理公式为： </p><p>Gray = R ∗ 0.299 + G ∗ 0.587 + B ∗ 0.114</p><p>其中：R、G、B 分别代表红绿蓝三种颜色；</p><h2 id="3、构建卷积神经网络"><a href="#3、构建卷积神经网络" class="headerlink" title="3、构建卷积神经网络"></a>3、构建卷积神经网络</h2><h3 id="3-1、卷积层"><a href="#3-1、卷积层" class="headerlink" title="3.1、卷积层"></a>3.1、卷积层</h3><p>卷积运算的过程为：</p><p>(1) 卷积核绕核内中心元素顺时针旋转180度；</p><p>(2) 将卷积核的中心元素对准需要处理的图像像素；</p><p>(3) 将需要处理的图像像素值作为权重与旋转后的卷积核相乘；</p><p>(4) 将上一步得到的值进行求和得到最终结果作为该图像像素的输出像素值。</p><p>本文选择用离散卷积核来对图像进行处理，因为离散卷积核进行的只是优先次的整数加法运算。没有浮点运算，这使得计算机很快的计算出结果。为本课题中所用的第一层网络，包括卷积层和池化层。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> tf<span class="token punctuation">.</span>name_scope<span class="token punctuation">(</span><span class="token string">'conv1'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      W_conv1 <span class="token operator">=</span> weight_variable<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"weight"</span><span class="token punctuation">)</span>      b_conv1 <span class="token operator">=</span> bias_variable<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'bias'</span><span class="token punctuation">)</span>      h_conv1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>          tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>x_image<span class="token punctuation">,</span> W_conv1<span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token string">"SAME"</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'conv'</span><span class="token punctuation">)</span>          <span class="token operator">+</span> b_conv1<span class="token punctuation">)</span>      h_pool1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>max_pool<span class="token punctuation">(</span>h_conv1<span class="token punctuation">,</span> ksize<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> strides<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                               padding<span class="token operator">=</span><span class="token string">"SAME"</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"pool"</span><span class="token punctuation">)</span></code></pre><p>先设计权重矩阵为[3,3,1,16]，设定偏置矩阵为[16], tf.nn. conv2d()函数即可完成卷积操作。首先，x_image即为输入图像，W_conv1即为卷积核(这里与权重矩阵相同)，strides是卷积步幅，在这设定为[1,1,1,1]。Padding是定义元素边框和元素内容之间的空间，只能是”SAME”（边缘填充）或者”VALID”（边缘不填充）。tf.nn.relu()是线性整流函数，其作用是将输入小于0的值幅值为0，输入大于0的值不变。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image020.gif"></p><h3 id="3-2、池化层"><a href="#3-2、池化层" class="headerlink" title="3.2、池化层"></a>3.2、池化层</h3><p>在通过卷积得到了特征了后，需要利用这些特征来进行分类。但这样产生的计算量是巨大的。为了减少计算量又同时保留原图像的信息，就需要对不同位置的特征进行聚合统计，这种聚合操作就叫为池化（pooling）操作。目前常用的池化操作为平均池化（Average pooling）和最大值池化（max pooling），在本课题中，选择最大值池化取采样窗口所有元素的最大值作为池化层的值，该方法简单易操作而且泛化能强。</p><p>tf.nn.max_pooling()函数实现了最大池化操作。h_conv1是需要池化的输入，可以看出 h_conv1是卷积层输出的特征图像（feature map），依然是[batch, height, width, channels]这样的图像。Ksize是池化窗口的大小，是一个四维向量，一般是[1, 特征图像的height, 特征图像的width, 1]，不需要对batch和channels上做池化，所以这两个维度设为1。Strides与卷积相似，是窗口在每一个维度上滑动的步长。Padding也和卷积类似，可以取’VALID’ 或者’SAME’。</p><h3 id="3-3、激活函数"><a href="#3-3、激活函数" class="headerlink" title="3.3、激活函数"></a>3.3、激活函数</h3><p>神经网络中的每个神经元节点接受上一层神经元的输出值作为本神经元的输入值，并将输入值传递给下一层，输入层神经元节点会将输入属性值直接传递给下一层（隐层或输出层）。在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数（又称激励函数）。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image022.gif"></p><p>神经网络主要采用sigmoid函数或者tanh函数，输出有界，很容易充当下一层的输入。本文采用的就是sigmoid函数，其表达式为：</p><p>Sigmoid的几何图像和导数图像如下图所示</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310111750894.png"></p><h2 id="4、仿真结果与分析"><a href="#4、仿真结果与分析" class="headerlink" title="4、仿真结果与分析"></a>4、仿真结果与分析</h2><p>神经网络的原始输出（也就是结点的直接输出结果）不是一个概率值，实质上只是输入的数值做了复杂的加权和与非线性处理之后的一个值而已，故而需要使用激活函数来输出变成概率分布。本组使用的Sigmoid函数，它的特性是将一个数压缩到0-1之间，压缩后的结果就可以作为二分类中某一类的概率值，由于是二分类问题，所以另一类的概率值自然就是1−Sigmoid(y)，这就表征出二分类的概率。</p><h3 id="4-1、交叉熵损失"><a href="#4-1、交叉熵损失" class="headerlink" title="4.1、交叉熵损失"></a>4.1、交叉熵损失</h3><p>这种概率分布就可以由交叉熵表示，交叉熵刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵损失的值越小，两个概率分布就越接近。可以看出当训练样本到达第25%时，交叉熵损失就已经小于0.5了。当训练样本达到100%，交叉熵损失已经小于0.001了。说明此模型的已经很接近真实输出。性能满足课题需求。另外由下图可以看出训练准确率在训练样本到达25%时已经接近0.95，在训练样本达到100%时，准确率接近99.9%，说明此模型的准确性也达到了课题需求。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/clip_image026.gif"></p><h3 id="4-2、-准确率验证"><a href="#4-2、-准确率验证" class="headerlink" title="4.2、 准确率验证"></a>4.2、 准确率验证</h3><p>建立模型之后，对于不同手势准确率进行测试。由结果可以看出，四种手势的识别准确率基本控制95%以上，虽然由于现场环境光照等原因的干扰，有时准确率低于90%，但是能很快调整，将准确率控制在92%以上。由此可见。此模型在准确率上完全符合要求。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310111803999.png"></p><h2 id="5、本章小结"><a href="#5、本章小结" class="headerlink" title="5、本章小结"></a>5、本章小结</h2><p>本章主要介绍了以卷积神经网络为核心的机器视觉算法，从卷积神经网络的数学原理开始，再到卷积神经网络的基础结构。搭建了一个用于分类手势图片的深度学习模型。由最终的仿真仿真结果可以看出：最终模型随着训练时间增长，误差逐渐减小至0.005以下。在此模型中，由20%的测试集可得出，其预测精准度约为92%。由此可以得出，此模型基本满足课题要求。可以用于机械手掌在手势识别上的要求。</p><p><strong>源码详见：<a href="https://github.com/Zwyywz/Undergraduate-graduation-project">https://github.com/Zwyywz/Undergraduate-graduation-project</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 卷积神经网络 </tag>
            
            <tag> TensorFlow </tag>
            
            <tag> 图像分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习与TensorFlow</title>
      <link href="/2020/04/01/deeplearningandtensorflow/"/>
      <url>/2020/04/01/deeplearningandtensorflow/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习与TensorFlow"><a href="#深度学习与TensorFlow" class="headerlink" title="深度学习与TensorFlow"></a>深度学习与TensorFlow</h1><h2 id="第一章-线性回归"><a href="#第一章-线性回归" class="headerlink" title="第一章 线性回归"></a>第一章 线性回归</h2><h3 id="1、神经元模型"><a href="#1、神经元模型" class="headerlink" title="1、神经元模型"></a>1、神经元模型</h3><p>首先，我们把生物神经元的模型抽象下图所示的数学结构:神经元输入向量x=[x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>…x<sub>n</sub>],经过函数映射: $f_{\theta}: \boldsymbol{x}$ →y后得到输出y，其中${\theta}$为函数f自身的参数。考虑一种简化的情况，即线性变换: $f(\boldsymbol{x})=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b$， 展开为标量形式: </p><p>$f(x)=w_{1} x_{1}+w_{2} x_{2}+w_{3} x_{3}+\cdots+w_{n} x_{n}+b$</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210401182603937.png"></p><p>参数$\theta$={w<sub>1</sub>,w<sub>2</sub>,w<sub>3</sub>w<sub>4</sub>，w<sub>4</sub>…….w<sub>n</sub>}确定了神经元的状态，通过固定${\theta}$参数即可确定此神经元的处理逻辑。当神经元输入节点数n= 1(单输入)时，神经元数学模型可进一步简化为: $y=w x+b$</p><p>此时我们可以绘制出神经元的输出y和输入x的变化趋势，随着输入信号x的增加，输出电平y也随之线性增加，其中w参数可以理解为直线的斜率, b参数为直线的偏置。</p><p>对于某个神经元来说，x和y的映射关系fw.b是未知但确定的。两点即可确定一条直线，为了估计w和b的值，我们只需从直线上采样任意2个数据点:$\left(x^{(1)}, y^{(1)}\right),\left(x^{(2)}, y^{(2)}\right)$即可，其中上标表示数据点编号:</p><p> $y^{(1)}=w x^{(1)}+b$</p><p> $y^{(2)}=w x^{(2)}+b$</p><p>当$\left(x^{(1)}, y^{(1)}\right)\neq\left(x^{(2)}, y^{(2)}\right)$时，即可解出w,b。可以看到，只需要观测两个不同数据点，就可完美求解单输入线性神经元模型的参数，对于N输入的线性神经元模型，只需要采样N + 1组不同数据点即可，似乎线性神经元模型可以得到完美解决。那么上述方法存在什么问题呢?</p><p>考虑对于任何采样点，都有可能存在观测误差，我们假设观测误差变量$\epsilon$属于均值为μ,方差为σ2的正态分布(NormalDistribution， 或高斯分布，Gaussian Distibution):$\mathcal{N}\left(\mu, \sigma^{2}\right)$， 则采样到的样本符合:<br>$$<br>y=w x+b+\epsilon, \epsilon \sim \mathcal{N}\left(\mu, \sigma^{2}\right)<br>$$<br>一旦引入观测误差后，即使简单如线性模型，如果仅采样两个数据点，可能会带来较大估计偏差。图中的数据点均带有观测误差，如果基于蓝色矩形块的两个数据点进行估计，则计算出的蓝色虚线与真实橙色直线存在较大偏差。为了减少观测误差引入的估计偏差，可以通过采样多组数据样本集合：</p><p>$$<br>D={\left(x^{(1)}, y^{(1)}\right),\left(x^{(2)}, y^{(2)}\right), \ldots,\left(x^{(n)}, y^{(n)}\right)}<br>$$</p><p>然后找出一条“最好”的直线，使得它尽可能地让所有采样点到该直线的误差之和最小。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210401185614687.png"></p><p>也就是说，由于观测误差e的存在，当我们采集了多个数据点D时，可能不存在一条直线完美的穿过所有采样点。退而求其次，我们希望能找到一条比较“好”的位于采样点中间的直线。那么怎么衡量“好”与“不好”呢?一个很自然的想法就是，求出当前模型的所有采样点上的预测值${w x^{(i)}}$ + b与真实值$y^{(i)}$之间的差的平方和作为总误差${L}$:<br>$$<br>\mathcal{L}=\frac{1}{n} \sum_{i=1}^{n}\left(w x^{(i)}+b-y^{(i)}\right)^{2}<br>$$</p><p>对于单输入的神经元模型，只需要两个样本，就能通过消元法求出方程组的精确解，这种通过严格的公式推导出的精确解称为解析解。这种算法固然简单直接，但是面对大规模、高维度数据的优化问题时计算效率极低，基本不可行。梯度下降算法是神经网络训练中最常用的优化算法，配合强大的图形处理芯片GPU的并行加速能力，非常适合优化海量数据的神经网络模型，自然也适合优化我们这里的神经元线性模型。</p><h3 id="2、梯度-Gradient-："><a href="#2、梯度-Gradient-：" class="headerlink" title="2、梯度(Gradient)："></a>2、<strong>梯度(Gradient)：</strong></h3><p>函数对各个自变量的偏导数组成的向<br>量。设函数z=f(x,y)在平面区域D内具有一阶连续偏导数，则对于每一个点P(x,y)∈D，向量$\left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)$为函数z=f(x,y)在点P的梯度，记做*gradf(x,y)*。梯度的方向是函数在该点变化最快的方向。</p><hr><p><strong>重点：</strong>以*f(x,y)=-(cos<suP>2</sup>x+sin<sup>2</sup>x)*为例；图中xy平面的红色箭头的长度表示梯度向量的模，箭头的方向表示梯度向量的方向。可以看到，箭头的方向总是指向当前位置函数值增速最大的方向，函数曲面越陡峭，箭头的长度也就越长，梯度的模也越大。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210402094531701.png"></p><p>函数在各处的梯度方向${\nabla}$f总是指向函数值增大的方向，那么梯度的反方向-$\nabla$f应指向函数值减少的方向。利用这一性质，只需要按照:</p><p>​                                                x’ = x - $\eta$·${\nabla}$f</p><p>来迭代更新x’，就能获得越来越小的函数值，其中n用来缩放梯度向量，一般设置为某较小的值，如0.01、 0.001 等。特别地，对于一维函数，上述向量形式可以退化成标量形式:</p><p>​                                                x’ = x - $\eta$·$\frac{dy}{dx}$</p><p>通过上式迭代更新x’若干次，这样得到的x’处的函数值y’,总是更有可能比在x处的函数值y小，优化参数的方法称为<strong>梯度下降算法</strong>。一般x表示模型输入，模型的待优化参数一 般用${\theta}$、w、b等符号表示。</p><hr><h3 id="3、线性回归-tensorflow实战"><a href="#3、线性回归-tensorflow实战" class="headerlink" title="3、线性回归-tensorflow实战"></a>3、线性回归-tensorflow实战</h3><p>首先我们需要采样自真实模型的多组数据，对于已知真实模型的玩具样例,我们直接，直接从指定的w= 1.477, b= 0.089的真实模型中直接采样:<br>                                            $$y=1.477 x+0.089$$<br>接下来实战训练单输入神经元线性模型。</p><p><strong>【采样数据】</strong>:</p><p>为了能够很好地模拟真实样本的观测误差，我们给模型添加误差自变量$\epsilon$，它采样自均值为0，标准差为0.01的高斯分布:$y=1.477 x+0.089+\epsilon, \epsilon \sim \mathcal{N}\left(\mu, \sigma^{2}\right)$</p><p>通过随机采样n= 100次，我们获得n个样本的训练数据集D<sup>train</sup>，代码如下:</p><pre class=" language-python"><code class="language-python">  data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#保存样本序列</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#循环采集100个点</span>    x <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#随机采样输入</span>    eps <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#采样高斯噪声</span>    y <span class="token operator">=</span> <span class="token number">1.477</span> <span class="token operator">*</span> x <span class="token operator">+</span> <span class="token number">0.089</span> <span class="token operator">+</span> eps <span class="token comment" spellcheck="true">#得到模型输出</span>    data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#保存样本点</span>  data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#转化为2D numpy 数组</span></code></pre><p>循环进行100次采样，每次从均匀习分布$\mathcal{U}\left(-10, 10\right)$中随机采样一个数据x， 同时从均值为0，方差为0.12的高斯分布$\mathcal{N}\left(0, 0.1^{2}\right)$中随机采样噪声$\epsilon$，根据真实模型生成y的数据,并保存为Numpy数组。</p><p><strong>【计算误差】</strong></p><p>循环计算在每个点$\left(x^{(i)}, y^{(i)}\right)$处的预测值与真实值之间差的平方并累加，从而获得训练集_上的均方误差损失值。代码如下:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mse</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>w<span class="token punctuation">,</span>points<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#根据当前的w,b计算均方差损失</span>  totalError <span class="token operator">=</span> <span class="token number">0</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    y <span class="token operator">=</span> points<span class="token punctuation">[</span>i <span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>    totalError <span class="token operator">+=</span> <span class="token punctuation">(</span>y <span class="token operator">-</span><span class="token punctuation">(</span>w <span class="token operator">*</span> x <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token comment" spellcheck="true">#计算差的平方，并且累加</span>  <span class="token keyword">return</span> totalError <span class="token operator">/</span> float<span class="token punctuation">(</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>【计算梯度】</strong></p><p>根据之前介绍的梯度下降算法，我们需要计算出函数在每一个点上的梯度信息:$\left(\frac{\partial L}{\partial w}, \frac{\partial L}{\partial b}\right)$。我们来推导一下梯度的表达式，首先考虑$\frac{\partial L}{\partial w}$，将均方差函数展开:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w}=\frac{\partial \frac{1}{n} \sum_{i=1}^{n}\left(w x^{(i)}+b-y^{(i)}\right)^{2}}{\partial w}=\frac{1}{n} \sum_{i=1}^{n} \frac{\partial\left(w x^{(i)}+b-y^{(i)}\right)^{2}}{\partial w}<br>$$<br>考虑到：$\frac{\partial g^{2}}{\partial w}=2 \cdot g \cdot \frac{\partial g}{\partial w} $<br>         因此：<br>$$<br>\begin{align}<br>\frac{\partial \mathcal{L}}{\partial w}<br>=&amp; \frac{1}{n} \sum_{i=1}^{n} 2\left(w x^{(i)}+b-y^{(i)}\right) \cdot \frac{\partial\left(w x^{(i)}+b-y^{(i)}\right)}{\partial w}\<br>=&amp; \frac{1}{n} \sum_{i=1}^{n} 2\left(w x^{(i)}+b-y^{(i)}\right) \cdot x^{(i)} \<br>=&amp;\frac{2}{n} \sum_{i=1}^{n}\left(w x^{(i)}+b-y^{(i)}\right) \cdot x^{(i)}\<br>\end{align}<br>$$</p><p>同样的方法：</p><p>$$<br>\begin{align}<br>\frac{\partial \mathcal{L}}{\partial b}<br>=&amp; \frac{\partial \frac{1}{n} \sum_{i=1}^{n}\left(w x^{(i)}+b-y^{(i)}\right)^{2}}{\partial b}\<br>=&amp; \frac{1}{n} \sum_{i=1}^{n} \frac{\partial\left(w x^{(i)}+b-y^{(i)}\right)^{2}}{\partial b}\<br>=&amp; \frac{1}{n} \sum_{i=1}^{n} 2\left(w x^{(i)}+b-y^{(i)}\right) \cdot 1 \<br>=&amp; \frac{2}{n} \sum_{i=1}^{n}\left(w x^{(i)}+b-y^{(i)}\right) \cdot y^{(i)}\<br>\end{align}<br>$$</p><p>我们只需要计算在每一一个点上面的 $((w x^{(i)}+b-y^{(i)})·x^{(i)}$和$w x^{(i)}+b-y^{(i)}$值，平均后即可得到偏导数$\left(\frac{\partial L}{\partial w}, \frac{\partial L}{\partial b}\right)$。实现如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">step_gradient</span><span class="token punctuation">(</span>b_current<span class="token punctuation">,</span>w_current<span class="token punctuation">,</span>points<span class="token punctuation">,</span>lr<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#计算误差函数所有点的导数，并且更新</span>  b_gradient <span class="token operator">=</span> <span class="token number">0</span>  w_gradient <span class="token operator">=</span> <span class="token number">0</span>  m <span class="token operator">=</span> float<span class="token punctuation">(</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> points<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    y <span class="token operator">=</span> points<span class="token punctuation">[</span>i <span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">#计算误差函数对b的导数：grad_b = 2(wx+b-y)</span>    b_gradient <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">/</span>m<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>w_current <span class="token operator">*</span> x <span class="token operator">+</span> b_current<span class="token punctuation">)</span> <span class="token operator">-</span>y<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#计算误差函数对w的导数：grad_w = 2(wx+b-y)*x</span>    w_gradient <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">/</span>m<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>w_current <span class="token operator">*</span> x <span class="token operator">+</span> b_current<span class="token punctuation">)</span> <span class="token operator">-</span>y<span class="token punctuation">)</span> <span class="token operator">*</span> x  <span class="token comment" spellcheck="true"># 根据梯度下降算法更新 w',b',其中lr 为学习率</span>  new_b <span class="token operator">=</span> b_current <span class="token operator">-</span> <span class="token punctuation">(</span>lr <span class="token operator">*</span> b_gradient<span class="token punctuation">)</span>  new_w <span class="token operator">=</span> w_current <span class="token operator">-</span> <span class="token punctuation">(</span>lr <span class="token operator">*</span> w_gradient<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>new_b<span class="token punctuation">,</span> new_w<span class="token punctuation">]</span></code></pre><p><strong>【梯度更新】</strong></p><p>在计算出误差函数在w和b处的梯度后，再来更新w和b的值。把对数据集的所有样本训练一次称为一个Epoch,共循环迭代num_ terations 个Epoch。实现如下:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">gradient_descent</span><span class="token punctuation">(</span>points<span class="token punctuation">,</span> starting_b<span class="token punctuation">,</span> starting_w<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_iterations<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 循环更新w,b 多次</span>  b <span class="token operator">=</span> starting_b <span class="token comment" spellcheck="true"># b 的初始值</span>  w <span class="token operator">=</span> starting_w <span class="token comment" spellcheck="true"># w 的初始值</span>  <span class="token comment" spellcheck="true"># 根据梯度下降算法更新多次</span>  <span class="token keyword">for</span> step <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_iterations<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 计算梯度并更新一次</span>    b<span class="token punctuation">,</span> w <span class="token operator">=</span> step_gradient<span class="token punctuation">(</span>b<span class="token punctuation">,</span> w<span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token punctuation">)</span>    loss <span class="token operator">=</span> mse<span class="token punctuation">(</span>b<span class="token punctuation">,</span> w<span class="token punctuation">,</span> points<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算当前的均方差，用于监控训练进度</span>    <span class="token keyword">if</span> step<span class="token operator">%</span><span class="token number">50</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 打印误差和实时的w,b 值</span>      <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"iteration:&amp;#123;step&amp;#125;, loss:&amp;#123;loss&amp;#125;, w:&amp;#123;w&amp;#125;, b:&amp;#123;b&amp;#125;"</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> w<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 返回最后一次的w,b</span></code></pre><p>主函数实现如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 加载训练集数据，这些数据是通过真实模型添加观测误差采样得到的</span>  lr <span class="token operator">=</span> <span class="token number">0.01</span> <span class="token comment" spellcheck="true"># 学习率</span>  initial_b <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 初始化b 为0</span>  initial_w <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 初始化w 为0</span>  num_iterations <span class="token operator">=</span> <span class="token number">1000</span>  <span class="token comment" spellcheck="true"># 训练优化1000 次，返回最优w*,b*和训练Loss 的下降过程</span>  <span class="token punctuation">[</span>b<span class="token punctuation">,</span> w<span class="token punctuation">]</span><span class="token operator">=</span> gradient_descent<span class="token punctuation">(</span>data<span class="token punctuation">,</span> initial_b<span class="token punctuation">,</span> initial_w<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> num_iterations<span class="token punctuation">)</span>  loss <span class="token operator">=</span> mse<span class="token punctuation">(</span>b<span class="token punctuation">,</span> w<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算最优数值解w,b 上的均方差</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Final loss:&amp;#123;loss&amp;#125;, w:&amp;#123;w&amp;#125;, b:&amp;#123;b&amp;#125;'</span><span class="token punctuation">)</span></code></pre><p>可以看到，第100次迭代时，w和b的值就已经比较接近真实模型了，更新1000次后得到的w*和b数值解与真实模型的非常接近。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210402113941430.png"></p><h2 id="第二章-分类问题"><a href="#第二章-分类问题" class="headerlink" title="第二章 分类问题"></a>第二章 分类问题</h2><p>考虑图片分类中最简单的任务之一：0~9 数字图片识别，它相对简单，而且也具有非常广泛的应用价值，比如邮政编码、快递单号、手机号码等都属于数字图片识别范畴。</p><h3 id="2-1-手写数字图片数据集"><a href="#2-1-手写数字图片数据集" class="headerlink" title="2.1 手写数字图片数据集"></a>2.1 手写数字图片数据集</h3><p>以手写的数字图片识别为例，需要收集大量的由真人书写的0-9 的数字图片，为了便于存储和计算，一般把收集的原始图片缩放到某个固定的大小(Size 或Shape)，比如96 个像素的行和96 个像素的列(96 × 96)，这张图片将作为输入数据x。同时，我们需要给每一张图片标注一个标签，它将作为图片的真实值𝑦，这个标签表明这张图片属于哪一个具体的类别，一般通过映射方式将类别名一一对应到从0 开始编号的数字，这种编码方式叫作数字编码。对于手写数字图片识别问题，编码更为直观，我们用数字的0-9 来表示类别名字为0-9 的图片。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210405151000637.png"></p><p>如果希望模型能够在新样本上也能具有良好的表现，即模型泛化能力较好，那么应该尽可能多地增加数据集的规模和多样性(Variance)，使得我们用于学习的训练数据集与真实的手写数字图片的分布(Ground-truth Distribution)尽可能的逼近，这样在训练数据集上面学到了模型能够很好的用于未见过的手写数字图片的预测。</p><p>采用开源的MNIST数据集，这是在机器学习领域中的一个经典问题。该问题解决的是把28x28像素的灰度手写数字图片识别为相应的数字，其中数字的范围从0到9。采集自不同书写风格的真实手写图片，一共70000 张图片。其中60000 张图片作为训练集D<sup>train</sup>，用来训练模型，剩下10000 张图片作为测试集D<sup>test</sup>，这些图片由真人书写，包含了如字体大小、书写风格、粗细等丰富的样式，确保这些图片的分布与真实的手写数字图片的分布尽可能的接近，从而保证了模型的泛化能力。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210405151917695.png"></p><p>一张图片包含了ℎ行，𝑤列，每个位置保存了像素值，像素值一般使用0~255 的整形数值来表达颜色强度信息，例如0 表示强度最低，255 表表示强度最高。如果是彩色图片，则每个像素点包含了R、G、B 三个通道的强度信息，分别代表红色通道、绿色通道、蓝色通道的颜色强度，所以与灰度图片不同，它的每个像素点使用一个1 维、长度为3 的向量(Vector)来表示，向量的3 个元素依次代表了当前像素点上面的R、G、B 颜色强值，因此彩色图片需要保存为形状是[ℎ, 𝑤, 3]的张量(Tensor，可以通俗地理解为3 维数组)。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210405152807104.png"></p><p>利用TensorFlow 自动在线下载MNIST 数据集，并转换为Numpy 数组格式:</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf <span class="token comment" spellcheck="true"># 导入TF 库</span><span class="token keyword">from</span> tensorflow <span class="token keyword">import</span> keras <span class="token comment" spellcheck="true"># 导入TF 子库keras</span><span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras <span class="token keyword">import</span> layers<span class="token punctuation">,</span> optimizers<span class="token punctuation">,</span> datasets <span class="token comment" spellcheck="true"># 导入TF 子库等</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x_val<span class="token punctuation">,</span> y_val<span class="token punctuation">)</span> <span class="token operator">=</span> datasets<span class="token punctuation">.</span>mnist<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 加载MNIST 数据集</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>tf<span class="token punctuation">.</span>convert_to_tensor<span class="token punctuation">(</span>x<span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">255</span><span class="token punctuation">.</span><span class="token operator">-</span><span class="token number">1</span> <span class="token comment" spellcheck="true"># 转换为浮点张量，并缩放到-1~1</span>y <span class="token operator">=</span> tf<span class="token punctuation">.</span>convert_to_tensor<span class="token punctuation">(</span>y<span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>int32<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 转换为整形张量</span>y <span class="token operator">=</span> tf<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>y<span class="token punctuation">,</span> depth<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># one-hot 编码</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> y<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>train_dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 构建数据集对象</span>train_dataset <span class="token operator">=</span> train_dataset<span class="token punctuation">.</span>batch<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 批量训练</span></code></pre><h3 id="2-2-模型构建"><a href="#2-2-模型构建" class="headerlink" title="2.2 模型构建"></a>2.2 模型构建</h3><p>对于是多输入、单输出的模型结构的话，可以使用向量形式来表示：<br>$$<br>y=\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}+b=\left[w_{1}, w_{2}, w_{3}, \ldots, w_{d_{i n}}\right] \cdot\left[\begin{array}{c}<br>x_{1} \<br>x_{2} \<br>x_{3} \<br>\vdots \<br>x_{d_{i n}}<br>\end{array}\right]+b<br>$$<br>通过组合多个多输入、单输出的神经元模型，可以拼成一个多输入、多输出的模型：𝒚 = 𝑾𝒙 + 𝒃。其中，𝒙 ∈ 𝑅<sup>𝑑<sub>in</sub></sup>，𝒃 ∈ 𝑅<sup>𝑑<sub>out</sub></sup>，𝒚 ∈ 𝑅<sup>𝑑<sub>out</sub></sup>，𝑾 ∈ 𝑅<sup>𝑑<sub>out</sub>×𝑑<sub>in</sub></sup>。</p><p>对于多输出节点、批量训练方式，我们将模型写成批量形式：𝒀 = 𝑿@𝑾 + 𝒃，其中，𝑿 ∈ 𝑅<sup>b*𝑑<sub>in</sub></sup>，𝒃 ∈ 𝑅<sup>𝑑<sub>out</sub></sup>，𝒚 ∈ 𝑅<sup>𝑑<sub>out</sub></sup>，𝑾 ∈ 𝑅<sup>𝑑<sub>out</sub>×𝑑<sub>in</sub></sup>。𝑑<sub>in</sub>表示输入节点数，𝑑<sub>out</sub>表示输出节点数；𝑿形状为[𝑏, 𝑑<sub>in</sub>]，表示𝑏个样本的输入数据，每个样本的特征长度为𝑑<sub>in</sub>；𝑾的形状为[𝑑<sub>in</sub>, 𝑑<sub>out</sub>]，共包含了𝑑<sub>in</sub> ∗ 𝑑<sub>out</sub>个网络参数；偏置向量𝒃 形状为𝑑<sub>out</sub>，每个输出节点上均添加一个偏置值；@符号表示矩阵相乘。</p><p>考虑两个样本，输入特征长度𝑑<sub>in</sub> = 3，输出特征长度𝑑<sub>out</sub> = 2的模型，展开为：<br>$$<br>\left[\begin{array}{ll}<br>o_{1}^{(1)} &amp; o_{2}^{(1)}<br>\<br>o_{1}^{(2)} &amp; o_{2}^{(2)}<br>\end{array}\right]=\left[\begin{array}{lll}<br>x_{1}^{(1)} &amp; x_{2}^{(1)} &amp; x_{3}^{(1)}<br>\<br>x_{1}^{(2)} &amp; x_{2}^{(2)} &amp; x_{3}^{(2)}<br>\end{array}\right]\left[\begin{array}{ll}<br>w_{11} &amp; w_{12}<br>\<br>w_{21} &amp; w_{22}<br>\<br>w_{31} &amp; w_{32}<br>\end{array}\right]+\left[\begin{array}{l}<br>b_{1}<br>\<br>b_{2}<br>\end{array}\right]<br>$$<br>其中𝑥1<sup>(1)</sup>、𝑜1<sup>(1)</sup>等符号的上标表示样本索引号(样本编号)，下标表示某个样本向量的元素。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210408151633039.png"></p><p>推广到图片，假设一张灰度图x使用矩阵存储，形状为：[h,w]。b张图片使用形状为[b,h,w]的张量X存储。而模型只接受向量形式的输入，因此需要将[h,w]打平成[h·w]的一维向量，长度d<sub>in</sub>=h·w。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210408152925228.png"></p><blockquote><p>==<strong>one-hot 编码(独热编码）：</strong>==</p><p>数字编码可以用一个数字来表示标签信息，此时输出只需要一个节点即可表示网络的预测类别值，例如数字1 表示猫，数字3 表示鱼等。但是数字编码一个最大的问题是，数字之间存在天然的大小关系，例如1 &lt; 2 &lt; 3，如果1、2、3 分别对应的标签是猫、狗、鱼，他们之间并没有大小关系，所以采用数字编码的时候会迫使模型去学习这种不必要的约束。</p><p>那么怎么解决这个问题呢？可以将输出设置为𝑑out个输出节点的向量，𝑑out与类别数相同，让第𝑖 ∈ [1, 𝑑out]个输出节点的值表示当前样本属于类别𝑖的概率𝑃(𝒙属于类别𝑖|𝒙)。我们只考虑输入图片只输入一个类别的情况，此时输入图片的真实标签已经唯一确定：如果物体属于第𝑖类的话，那么索引为𝑖的位置上设置为1，其他位置设置为0，我们把这种编码方式叫作<strong>one-hot 编码(独热编码)</strong></p></blockquote><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210408153228789.png"></p><p>手写数字图片的总类别数有10 种，即输出节点数𝑑out = 10，那么对于某个样本，假设它属于类别𝑖，即图片的中数字为𝑖，只需要一个长度为10 的向量𝒚，向量𝒚的索引号为𝑖的元素设置为1，其他位为0。比如图片0 的One-hot 编码为[1,0,0, … ,0]，图片2 的Onehot编码为[0,0,1, … ,0]，图片9 的One-hot 编码为[0,0,0, … ,1]。，相对于数字编码来说，占用较多的存储空间，所以一般在存储时还是采用数字编码，在计算时，根据需要来把数字编码转换成One-hot 编码。</p><pre class=" language-python"><code class="language-python">y <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 数字编码的4 个样本标签</span>y <span class="token operator">=</span> tf<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>y<span class="token punctuation">,</span> depth<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># one-hot 编码，指定类别总数为10</span><span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token comment" spellcheck="true">###输出</span>tf<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>float32<span class="token punctuation">)</span><span class="token comment" spellcheck="true">###</span></code></pre><p>输入是一张打平后的图片向量𝒙 ∈ 𝑅<sup>784</sup>，输出是一个长度为10 的向量 ∈ 𝑅<sup>10</sup>，图片的真实标签𝑦经过One-hot 编码后变成长度为10 的非0 即1 的稀疏向量𝒚 ∈ {0,1}<sup>10</sup>。预测模型采用多输入、多输出的线性模型 = 𝑾<sup>𝐓</sup>𝒙 + 𝒃，其中模型的输出记为输入的预测值 ，我们希望 越接近真实标签𝒚越好。一般把输入经过一次(线性)变换叫作<strong>一层网络</strong>。</p><h3 id="2-3-误差计算"><a href="#2-3-误差计算" class="headerlink" title="2.3 误差计算"></a>2.3 误差计算</h3><p>对于𝑛个样本的均方差损失函数可以表达为：<br>$$<br>\mathcal{L}(\boldsymbol{o}, \boldsymbol{y})=\frac{1}{n} \sum_{i=1}^{n} \sum_{j=1}^{10}\left(o_{j}^{(i)}-y_{j}^{(i)}\right)^{2}<br>$$<br>现在我们只需要采用梯度下降算法来优化损失函数得到𝑾, 𝒃的最优解，然后再利用求得的模型去预测未知的手写数字图片𝒙 ∈ D<sup>test</sup>。</p><p>这里最起码存在两个问题：</p><ul><li><input disabled="" type="checkbox"> <strong>线性模型</strong> 是机器学习中间最简单的数学模型之一，参数量少，计算简单，但是只能表达线性关系。即使是简单如数字图片识别任务，它也是属于图片识别的范畴，如果只使用一个简单的线性模型去逼近复杂的人脑图片识别模型，很显然不能胜任。</li><li><input disabled="" type="checkbox"> <strong>表达能力</strong> 体现为逼近复杂分布的能力。上面的解决方案只使用了少量神经元组成的一层网络模型，相对于人脑中千亿级别的神经元互联结构，它的表达能力明显偏弱。</li></ul><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210408160825603.png"></p><h3 id="2-4-非线性模型"><a href="#2-4-非线性模型" class="headerlink" title="2.4 非线性模型"></a>2.4 非线性模型</h3><p>既然线性模型不可行，我们可以给线性模型嵌套一个非线性函数，即可将其转换为非线性模型。我们把这个非线性函数称为激活函数(Activation Function)，用𝜎表示：o= 𝜎(𝑾𝒙 + 𝒃)，这里的𝜎代表了某个具体的非线性激活函数，如Sigmoid 函数、ReLU 函数。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210408161820924.png"></p><p>ReLU 函数非常简单，在𝑦 = 𝑥的基础上面截去了𝑥 &lt; 0的部分，可以直观地理解为ReLU 函数仅保留正的输入部份，清零负的输入，具有单边抑制特性。ReLU 函数却有优良的非线性特性，而且梯度计算简单，训练稳定，是深度学习模型使用最广泛的激活函数之一。我们这里通过嵌套ReLU 函数将模型转换为非线性模型：o= ReLU(𝑾𝒙 + 𝒃)</p><h3 id="2-5-表达能力"><a href="#2-5-表达能力" class="headerlink" title="2.5 表达能力"></a>2.5 表达能力</h3><p>针对于模型的表达能力偏弱的问题，可以通过重复堆叠多次变换来增加其表达能力：<br>$$<br>\begin{align}<br>h1 =&amp; ReLU(W_1X+b1)\<br>h2 =&amp; ReLU(W_2X+b2)\<br>o =&amp; W_3h2+b_3<br> \end{align}<br>$$<br>把第一层神经元的输出值𝒉1作为第二层神经元模型的输入，把第二层神经元的输出𝒉2作为第三层神经元的输入，最后一层神经元的输出作为模型的输出 。函数的嵌套表现为网络层的前后相连，每堆叠一个(非)线性环节，网络层数增加一层。我们把输入节点𝒙所在的层叫作输入层，每一个非线性模块的输出𝒉𝑖连同它的网络层参数𝑾𝑖和𝒃𝑖称为一层网络层，特别地，对于网络中间的层，叫作隐藏层，最后一层叫作输出层。这种由大量神经元模型连接形成的网络结构称为神经网络(Neural Network)。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210408163123638.png"></p><h3 id="2-6-手写数字图片识别-Tensorflow实战"><a href="#2-6-手写数字图片识别-Tensorflow实战" class="headerlink" title="2.6 手写数字图片识别-Tensorflow实战"></a>2.6 手写数字图片识别-Tensorflow实战</h3><p>对于第一层模型来说，它接受的输入𝒙 ∈ 𝑅<sup>784</sup>，输出𝒉1 ∈ 𝑅<sup>56</sup>设计为长度为256 的向量，不需要显式地编写$𝒉1 = ReLU(𝑾_1𝒙 + 𝒃_1)$的计算逻辑，在TensorFlow 中通过一行代码即可实现：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 创建一层网络，设置输出节点数为256，激活函数类型为ReLU</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span></code></pre><p>使用TensorFlow 的Sequential 容器可以非常方便地搭建多层的网络。对于3 层网络，我们可以通过快速完成3 层网络的搭建：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 利用Sequential 容器封装3 个网络层，前网络层的输出默认作为下一层的输入</span>model <span class="token operator">=</span> keras<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token comment" spellcheck="true"># 3 个非线性层的嵌套模型</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 隐藏层1</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 隐藏层2</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出层，输出节点数为10</span></code></pre><p>第1 层的输出节点数设计为256，第2 层设计为128，输出层节点数设计为10。直接调用这个模型对象model(x)就可以返回模型最后一层的输出𝑜。</p><p>搭建完成3 层神经网络的对象后，给定输入𝒙，调用model(𝒙)得到模型输出𝑜后，通过MSE 损失函数计算当前的误差ℒ：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 构建梯度记录环境</span>    <span class="token comment" spellcheck="true"># 打平操作，[b, 28, 28] => [b, 784]</span>    x <span class="token operator">=</span> tf<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Step1. 得到模型输出output [b, 784] => [b, 10]</span>    out <span class="token operator">=</span> model<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># [b] => [b, 10]</span>    y_onehot <span class="token operator">=</span> tf<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>y<span class="token punctuation">,</span> depth<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 计算差的平方和，[b, 10]</span>    loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>out<span class="token operator">-</span>y_onehot<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 计算每个样本的平均误差，[b]</span>    loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_sum<span class="token punctuation">(</span>loss<span class="token punctuation">)</span> <span class="token operator">/</span> x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre><p>再利用TensorFlow 提供的自动求导函数tape.gradient(loss, model.trainable_variables)求出模型中所有参数的梯度信息$\frac{\partial L}{\partial 𝜃}$, 𝜃 ∈ {𝑾1, 𝒃1, 𝑾2, 𝒃2, 𝑾3, 𝒃3}。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Step3. 计算参数的梯度 w1, w2, w3, b1, b2, b3</span>grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> model<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span></code></pre><p>计算获得的梯度结果使用grads 列表变量保存。再使用optimizers 对象自动按照梯度更新法则去更新模型的参数𝜃。</p><p>$$𝜃’ = 𝜃 - \eta·\frac{\partial L}{\partial 𝜃}$$</p><p>实现如下:</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 自动计算梯度</span>grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> model<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># w' = w - lr * grad，更新网络参数</span>optimizer<span class="token punctuation">.</span>apply_gradients<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>grads<span class="token punctuation">,</span> model<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>由于3 层的神经网络表达能力较强，手写数字图片识别任务相对简单，误差值可以较快速、稳定地下降，其中，把对数据集的所有样本迭代一遍叫作一个Epoch，我们可以在间隔数个Epoch 后测试模型的准确率等指标，方便监控模型的训练效果。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210408180132023.png"></p><h2 id="第三章-TensorFlow编程基础"><a href="#第三章-TensorFlow编程基础" class="headerlink" title="第三章 TensorFlow编程基础"></a>第三章 TensorFlow编程基础</h2><h3 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h3><p>1、<strong>数值类型</strong>：张量[Tensor]是[TensorFlow] 的主要数据载体，根据维度数来区分，可分为：</p><ul><li><p>标量(Scalar)。单个的实数，如1.2, 3.4 等，维度(Dimension)数为0，shape 为[]。</p></li><li><p>向量(Vector)。𝑛个实数的有序集合，通过中括号包裹，如[1.2]，[1.2, 3.4]等，维度数<br>为1，长度不定，shape 为[𝑛]。</p></li><li><p>矩阵(Matrix)。。𝑛行𝑚列实数的有序集合，如[[1,2], [3,4]]，也可以写成$\left[ \begin{matrix} 1 &amp; 2\ 3 &amp; 4 \end{matrix} \right] $</p></li><li><p>张量(Tensor)。所有维度数dim &gt; 2的数组统称为张量。张量的每个维度也作轴(Axis)，一般维度代表了具体的物理含义，比如Shape 为[2,32,32,3]的张量共有4 维，如果表示图片数据的话，每个维度/轴代表的含义分别是图片数量、图片高度、图片宽度、图片通道数，其中2 代表了2 张图片，32 代表了高、宽均为32，3 代表了RGB 共3 个通道。张量的维度数以及每个维度所代表的具体物理含义需要由用户自行定义。</p></li></ul><p>首先来看标量在TensorFlow 是如何创建的，实现如下：</p><pre class=" language-python"><code class="language-python">b <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor([1. 2. 1. 9.], shape=(4,), dtype=float32)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将TF 张量的数据导出为numpy 数组格式</span></code></pre><p>同样的方法，定义矩阵的实现如下：</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor([</span><span class="token comment" spellcheck="true">#[1 2]</span><span class="token comment" spellcheck="true"># [3 4]]</span><span class="token comment" spellcheck="true"># shape=(2, 2), dtype=int32) </span><span class="token comment" spellcheck="true">#(2, 2)</span></code></pre><p>2、<strong>字符串类型</strong>：除了丰富的数值类型张量外，TensorFlow 还支持字符串(String) 类型的数据。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor(b'hello world', shape=(), dtype=string)</span></code></pre><p>在tf.strings 模块中，提供了常见的字符串类型的工具函数，如小写化lower()、拼接<br>join()、长度length()、切分split()等。</p><pre class=" language-python"><code class="language-python">b <span class="token operator">=</span> tf<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>lower<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor(b'hello world', shape=(), dtype=string)</span></code></pre><p>3、<strong>布尔类型</strong>：为了方便表达比较运算操作的结果，TensorFlow 还支持布尔类型(Boolean，简称bool)的张量。布尔类型的张量只需要传入Python 语言的布尔类型数据，转换成TensorFlow 内部布尔型。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建布尔类型标量</span><span class="token comment" spellcheck="true">#tf.Tensor(True, shape=(), dtype=bool)</span>b <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建布尔类型向量</span><span class="token comment" spellcheck="true">#tf.Tensor([ True False], shape=(2,), dtype=bool)</span></code></pre><h3 id="3-2-数值精度"><a href="#3-2-数值精度" class="headerlink" title="3.2 数值精度"></a>3.2 数值精度</h3><p>对于数值类型的张量，可以保存为不同字节长度的精度，如浮点数3.14 既可以保存为16 位(Bit)长度，也可以保存为32 位甚至64 位的精度。位越长，精度越高，同时占用的内存空间也就越大。常用的精度类型有tf.int16、tf.int32、tf.int64、tf.float16、tf.float32、tf.float64 等，其中tf.float64 即为tf.double.</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">123456789</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>int16<span class="token punctuation">)</span>b <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">123456789</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor(-13035, shape=(), dtype=int16)</span><span class="token comment" spellcheck="true">#tf.Tensor(123456789, shape=(), dtype=int32)</span></code></pre><p>可以看到，保存精度过低时，数据123456789 发生了溢出，得到了错误的结果，一般使用tf.int32、tf.int64 精度。对于浮点数，高精度的张量可以表示更精准的数据。</p><p><strong>读取精度</strong>：通过访问张量的dtype 成员属性可以判断张量的保存精度。对于某些只能处理指定精度类型的运算操作，需要提前检验输入张量的精度类型，并将不符合要求的张量进行类型转换。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'before:'</span><span class="token punctuation">,</span>a<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 读取原有张量的数值精度</span><span class="token keyword">if</span> a<span class="token punctuation">.</span>dtype <span class="token operator">!=</span> tf<span class="token punctuation">.</span>float32<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果精度不符合要求，则进行转换</span>  a <span class="token operator">=</span> tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>a<span class="token punctuation">,</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># tf.cast 函数可以完成精度转换</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'after :'</span><span class="token punctuation">,</span>a<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 打印转换后的精度</span></code></pre><h3 id="3-3-待优化张量"><a href="#3-3-待优化张量" class="headerlink" title="3.3 待优化张量"></a>3.3 待优化张量</h3><p>为了区分需要计算梯度信息的张量与不需要计算梯度信息的张量，TensorFlow 增加了一种专门的数据类型来支持梯度信息的记录：tf.Variable。tf.Variable 类型在普通的张量类型基础上添加了name，trainable 等属性来支持计算图的构建。。由于梯度运算会消耗大量的计算资源，而且会自动更新相关参数，对于不需要的优化的张量，如神经网络的输入𝑿，不需要通过tf.Variable 封装。</p><p>通过 tf.Variable()函数可以将普通张量转换为待优化张量：</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建TF 张量</span>aa <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 转换为Variable 类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>aa<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aa<span class="token punctuation">.</span>trainable<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Variable 类型张量的属性</span></code></pre><h3 id="3-4-创建张量"><a href="#3-4-创建张量" class="headerlink" title="3.4 创建张量"></a>3.4 创建张量</h3><p>TensorFlow 中，可以通过多种方式创建张量，如从Python 列表对象创建，从umpy 数组创建，或者创建采样自某种已知分布的张量等。</p><p>==<strong>1、从数组、列表对象创建</strong>:==</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> tf<span class="token punctuation">.</span>convert_to_tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 从列表创建张量</span><span class="token comment" spellcheck="true">#f.Tensor([1. 2.], shape=(2,), dtype=float32)</span>b <span class="token operator">=</span> tf<span class="token punctuation">.</span>convert_to_tensor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 从数组中创建张量</span><span class="token comment" spellcheck="true">#tf.Tensor([[1. 2.] [3. 4.]], shape=(2, 2), dtype=float64)</span></code></pre><p>需要注意的是，Numpy 浮点数数组默认使用64 位精度保存数据，转换到Tensor 类型时精<br>度为tf.float64，可以在需要的时候将其转换为tf.float32 类型。</p><p>==<strong>2、创建全0 或全1 张量</strong>==</p><p>将张量创建为全0 或者全1 数据是非常常见的张量初始化手段。考虑线性变换𝒚 = 𝑾𝒙 + 𝒃，将权值矩阵𝑾初始化为全1 矩阵，偏置b 初始化为全0 向量，此时线性变化层输出𝒚 = 𝒙，因此是一种比较好的层初始化状态。通过tf.zeros()和tf.ones()即可创建任意形状，且内容全0 或全1 的张量。例如，创建为0 和为1 的标量：</p><pre class=" language-python"><code class="language-python">c <span class="token operator">=</span> tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>d <span class="token operator">=</span> tf<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建全0，全1 的标量</span><span class="token comment" spellcheck="true">#tf.Tensor(0.0, shape=(), dtype=float32)</span><span class="token comment" spellcheck="true">#tf.Tensor(1.0, shape=(), dtype=float32)</span>e <span class="token operator">=</span> tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#创建全0 矩阵，指定shape 为2 行2 列</span>f <span class="token operator">=</span> tf<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#创建全1 矩阵，指定shape 为3 行2 列</span></code></pre><p>通过tf.zeros_like, tf.ones_like 可以方便地新建与某个张量shape 一致，且内容为全0 或全1 的张量。例如，创建与张量𝑨形状一样的全0 张量：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建一个与a 形状相同，但是全1 的新矩阵</span>tf<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建一个与a 形状相同，但是全0 的新矩阵</span></code></pre><p>==<strong>3、创建自定义数值张量</strong>==</p><p>除了初始化为全0，或全1 的张量之外，有时也需要全部初始化为某个自定义数值的<br>张量，比如将张量的数值全部初始化为−1等。通过 tf.fill(shape, value)可以创建全为自定义数值value 的张量，形状由shape 参数指定。例如，创建元素为−1的标量：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>fill<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建-1 的标量</span>tf<span class="token punctuation">.</span>fill<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建-1 的向量</span>tf<span class="token punctuation">.</span>fill<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建2 行2 列，元素全为99 的矩阵</span></code></pre><p>==<strong>3、创建已知分布的张量</strong>==</p><p>正态分布(Normal Distribution，或Gaussian Distribution)和均匀分布(Uniform Distribution)是最常见的分布之一，创建采样自这2 种分布的张量非常有用，比如在卷积神经网络中，卷积核张量𝑾初始化为正态分布有利于网络的训练；在对抗生成网络中，隐藏变量𝒛一般采样自均匀分布。</p><p>通过 tf.random.normal(shape, mean=0.0, stddev=1.0)可以创建形状为shape，均值为mean，标准差为stddev 的正态分布𝒩(mean, stddev2)。例如，创建均值为0，标准差为1的正态分布：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建标准正态分布的张量</span></code></pre><p>通过tf.random.uniform(shape, minval=0, maxval=None, dtype=tf.float32)可以创建采样自[minval, maxval)区间的均匀分布的张量。例如创建采样自区间[0,1)，shape 为[2,2]的矩阵：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建采样自[0,1)均匀分布的矩阵</span></code></pre><p><strong>==5、创建序列==</strong></p><p>在循环计算或者对张量进行索引时，经常需要创建一段连续的整型序列，可以通过tf.range()函数实现。tf.range(limit, delta=1)可以创建[0, limit)之间，步长为delta 的整型序列，不包含limit 本身。例如，创建0~10，步长为1 的整型序列：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 0~10，不包含10</span>tf<span class="token punctuation">.</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>delta<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#创建0~10，步长为2 的整形序列</span></code></pre><h3 id="3-5-张量的典型应用"><a href="#3-5-张量的典型应用" class="headerlink" title="3.5 张量的典型应用"></a>3.5 张量的典型应用</h3><p>==1、<strong>标量</strong>==：在 TensorFlow 中，标量最容易理解，它就是一个简单的数字，维度数为0，shape 为<br>[]。标量的一些典型用途是误差值的表示、各种测量指标的表示，比如准确度(Accuracy，简称acc)，精度(Precision)和召回率(Recall)等。</p><pre class=" language-python"><code class="language-python">out <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#随机模拟网络输出</span>y <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 随机构造样本真实标签</span>y <span class="token operator">=</span> tf<span class="token punctuation">.</span>one_hot<span class="token punctuation">(</span>y<span class="token punctuation">,</span> depth<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># one-hot 编码</span>loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>losses<span class="token punctuation">.</span>mse<span class="token punctuation">(</span>y<span class="token punctuation">,</span> out<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算每个样本的MSE</span>loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>loss<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 平均MSE,loss 应是标量</span><span class="token keyword">print</span><span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor(0.19950335, shape=(), dtype=float32)</span></code></pre><p>**==2、向量==**：向量是一种非常常见的数据载体，如在全连接层和卷积神经网络层中，偏置张量𝒃就<br>使用向量来表示。如图 4.2 所示，每个全连接层的输出节点都添加了一个偏置值，把所有输出节点的偏置表示成向量形式：$b=\left[ \begin{matrix} b_1 \ b_2 \end{matrix} \right] $</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210415091950106.png"></p><p>考虑 2 个输出节点的网络层，我们创建长度为2 的偏置向量𝒃，并累加在每个输出节点上：</p><pre class=" language-python"><code class="language-python">z <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>b <span class="token operator">=</span> tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建偏置向量</span>z <span class="token operator">=</span> z <span class="token operator">+</span> b <span class="token comment" spellcheck="true"># 累加上偏置向量</span></code></pre><p>**==3、矩阵==**：矩阵也是非常常见的张量类型，比如全连接层的批量输入张量𝑿的形状为[𝑏, 𝑑in]，其<br>中𝑏表示输入样本的个数，即Batch Size，𝑑in表示输入特征的长度。</p><pre class=" language-python"><code class="language-python">x <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 2 个样本，特征长度为4 的张量</span>w <span class="token operator">=</span> tf<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 定义W 张量</span>b <span class="token operator">=</span> tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 定义b 张量</span>o <span class="token operator">=</span> x@w<span class="token operator">+</span>b</code></pre><p>其中𝑿和𝑾张量均是矩阵，上述代码实现了一个线性变换的网络层，激活函数为空。一般地，𝜎(𝑿@𝑾 + 𝒃)网络层称为全连接层，在TensorFlow 中可以通过Dense 类直接实现，特别地，当激活函数𝜎为空时，全连接层也称为线性层。</p><p>**==4、三维张量==**：三维的张量一个典型应用是表示序列信号，它的格式是：𝑿 = [𝑏, sequence len, feature len]。其中𝑏表示序列信号的数量，sequence len 表示序列信号在时间维度上的采样点数或步数，feature len 表示每个点的特征长度。后期NLP自然语言处理会用到。</p><p>**==5、四维张量==**：四维张量在卷积神经网络中应用非常广泛，它用于保存特征图(Feature maps)数据，格式一般定义为：[𝑏, ℎ, w, 𝑐]。其中𝑏表示输入样本的数量，ℎ/ 分别表示特征图的高/宽，𝑐表示特征图的通道数。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210415094312131.png"></p><h3 id="3-6-索引与切片"><a href="#3-6-索引与切片" class="headerlink" title="3.6  索引与切片"></a>3.6  索引与切片</h3><p>通过索引与切片操作可以提取张量的部分数据。</p><p>**==1、索引==**：在 TensorFlow 中，支持基本的[𝑖] [𝑗] ⋯标准索引方式，也支持通过逗号分隔索引号的索引方式。类似于C语言中的数组。</p><p>**==2、切片==**：通过start: end: step切片方式可以方便地提取一段数据，其中start 为开始读取位置的索<br>引，end 为结束读取位置的索引(不包含end 位)，step 为采样步长。</p><h2 id="第四章-神经网络"><a href="#第四章-神经网络" class="headerlink" title="第四章 神经网络"></a>第四章 神经网络</h2><p>在第一章中已经介绍了神经元模型，当选择阶跃函数为激活函数时，虽然单个神经元结合阶跃函数能够完成简单的二分类问题，但是阶跃函数在𝑧 = 0处是不连续的，其他位置导数为0，无法利用梯度下降算法进行参数优化。</p><p>为了能够让感知机模型能够从数据中间自动学习，Frank Rosenblatt 提出了感知机（神经元）的学习算法：</p><table><thead><tr><th align="left">More Actions算法 1：感知机训练算法</th></tr></thead><tbody><tr><td align="left">初始化参数𝒘 = 0, 𝑏 = 0</td></tr><tr><td align="left">repeat</td></tr><tr><td align="left">从训练集随机采样一个样本(𝒙𝑖, 𝑦𝑖)</td></tr><tr><td align="left">计算感知机的输出 = sign(𝒘𝐓𝒙𝑖 + 𝑏)</td></tr><tr><td align="left">如果 𝒙𝑖≠ 𝑦𝑖：</td></tr><tr><td align="left">输出：分类网络参数𝒘和𝑏</td></tr><tr><td align="left">𝒘′ ← 𝒘 + 𝜂 ∙ 𝑦𝑖 ∙ 𝒙𝒊</td></tr><tr><td align="left">𝑏′ ← 𝑏 + 𝜂 ∙ 𝑦𝑖</td></tr><tr><td align="left">until 训练次数达到要求</td></tr><tr><td align="left">输出：分类网络参数𝒘和𝑏</td></tr></tbody></table><p>其中𝜂为学习率。</p><p>但是以感知机为代表的线性模型不能解决异或(XOR)等线性不可分问题，尽管感知机模型不能解决线性不可分问题，但也可以通过嵌套多层神经网络可以解决。</p><h3 id="4-1-全连接层"><a href="#4-1-全连接层" class="headerlink" title="4.1 全连接层"></a><strong>4.1 全连接层</strong></h3><p>感知机模型的不可导特性严重约束了它的潜力，使得它只能解决极其简单的任务。现代深度学习动辄数百万甚至上亿的参数规模，但它的核心结构与感知机并没有多大差别。它在感知机的基础上，将不连续的阶跃激活函数换成了其它平滑连续可导的激活函数，并通过堆叠多个网络层来增强网络的表达能力。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210512125705818.png"></p><p>如上图所示，并行堆叠了2 个神经元，即2 个替换了激活函数的感知机，构成3 输入节点、2 个输出节点的网络层。其中第一个输出节点的输出为：</p><p>$$<br>o_1 = 𝜎(𝑤_{11} ∙ 𝑥<em>1 + 𝑤</em>{21} ∙ 𝑥<em>2 + 𝑤</em>{31} ∙ 𝑥<em>3 + 𝑏_1)<br>$$<br>第二个输出节点的输出为：<br>$$<br>o_2 = 𝜎(𝑤</em>{12} ∙ 𝑥<em>1 + 𝑤</em>{22} ∙ 𝑥<em>2 + 𝑤</em>{32} ∙ 𝑥<em>3 + 𝑏_2)<br>$$<br>输出向量为𝒐 = [𝑜1, 𝑜2]。整个网络层可以通过矩阵关系式表达：<br>$$<br>\left[ \begin{matrix} o_1 &amp; o_2 \end{matrix} \right]= \left[ \begin{matrix} x_1 &amp; x_2 &amp; x_3 \end{matrix} \right] \bullet  \left[ \begin{matrix} w</em>{11} &amp; w_{12}\ w_{21} &amp; w_{22}\ w_{31} &amp; w_{32} \end{matrix} \right] + \left[ \begin{matrix} b_1 &amp; b_2 \end{matrix} \right]<br>$$<br>即: $ O =  X \bullet W + b $</p><p>其中输出矩阵𝑶包含了𝑏个样本的输出特征，由于每个输出节点与全部的输入节点相连接，这种网络层称为全连接层(Fully-connected Layer)，𝑾矩阵叫做全连接层的权值矩阵，𝒃向量叫做全连接层的偏置向量。</p><p>全连接层有两种实现方式：<strong>张量方式实现</strong>和<strong>层方式实现</strong></p><p><strong>1、张量方式实现</strong>：要实现全连接层，只需要定义好权值张量𝑾和偏置张量𝒃，并利用TensorFlow 提供的批量矩阵相乘函数tf.matmul()即可完成网络层的计算。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">##创建输入𝑿矩阵为𝑏 = 2个样本，每个样本的输入特征长度为𝑑in = 784，输出节点数为𝑑out = 256，故定义权值矩阵𝑾的shape 为[784,256]，并采用正态分布初始化𝑾；</span>xx <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">784</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##偏置向量𝒃的shape 定义为[256]，在计算完𝑿@𝑾后相加即可，</span>ww1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>truncated_normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stddev<span class="token operator">=</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##最终全连接层的输出𝑶的shape 为[2,256]，即2 个样本的特征，每个特征长度为256</span>bb1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>oo1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x<span class="token punctuation">,</span>w1<span class="token punctuation">)</span> <span class="token operator">+</span> b1 <span class="token comment" spellcheck="true"># 线性变换</span>oo1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>o1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 激活函数</span></code></pre><p><strong>2、层方式实现：</strong></p><blockquote><p>全连接层本质上是矩阵的相乘和相加运算，实现并不复杂。但是作为最常用的网络层之一，TensorFlow 中有更高层、使用更方便的层实现方式：layers.Dense(units, activation)。通过layer.Dense 类，只需要指定输出节点数Units 和激活函数类型activation 即可。需要注意的是，输入节点数会根据第一次运算时的输入shape 确定，同时根据输入、输出节点数自动创建并初始化权值张量𝑾和偏置张量𝒃，因此在新建类Dense 实例时，并不会立即创建权值张量𝑾和偏置张量𝒃，而是需要调用build 函数或者直接进行一次前向计算，才能完成网络参数的创建。其中activation 参数指定当前层的激活函数，可以为常见的激活函数或自定义激活函数，也可以指定为None，即无激活函数。</p></blockquote><pre class=" language-python"><code class="language-python">x <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras <span class="token keyword">import</span> layers <span class="token comment" spellcheck="true"># 导入层模块</span><span class="token comment" spellcheck="true"># 创建全连接层，指定输出节点数和激活函数</span>fc <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span>h1 <span class="token operator">=</span> fc<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过fc 类实例完成一次全连接层的计算，返回输出张量</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210512124340498.png"></p><p>上述通过一行代码即可以创建一层全连接层fc，并指定输出节点数为512，输入的节点数在fc(x)计算时自动获取，并创建内部权值张量𝑾和偏置张量𝒃。</p><h3 id="4-2-神经网络"><a href="#4-2-神经网络" class="headerlink" title="4.2 神经网络"></a>4.2 神经网络</h3><p>通过层层堆叠的全连接层，保证前一层的输出节点数与当前层的输入节点数匹配，即可堆叠出任意层数的网络。我们把这种由神经元相互连接而成的网络叫做神经网络。通过堆叠4 个全连接层，可以获得层数为4 的神经网络，由于每层均为全连接层，称为全连接网络，其中第1~3 个全连接层在网络中间，称之为隐藏层1、2、3，最后一个全连接层的输出作为网络的输出，称为输出层。隐藏层1、2、3 的输出节点数分别为[256,128,64]，输出层的输出节点数为10。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210512125014472.png"></p><p>采用tf.keras实现上述网络：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tfx <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 导入常用网络层layers</span><span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras <span class="token keyword">import</span> layers<span class="token punctuation">,</span>Sequentialfc1 <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 隐藏层1</span>fc2 <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 隐藏层2</span>fc3 <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 隐藏层3</span>fc4 <span class="token operator">=</span> layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>None<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出层</span>x <span class="token operator">=</span> tf<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token operator">*</span><span class="token number">28</span><span class="token punctuation">]</span><span class="token punctuation">)</span>h1 <span class="token operator">=</span> fc1<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过隐藏层1 得到输出</span>h2 <span class="token operator">=</span> fc2<span class="token punctuation">(</span>h1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过隐藏层2 得到输出</span>h3 <span class="token operator">=</span> fc3<span class="token punctuation">(</span>h2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过隐藏层3 得到输出</span>h4 <span class="token operator">=</span> fc4<span class="token punctuation">(</span>h3<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过输出层得到网络输出</span><span class="token comment" spellcheck="true"># 导入Sequential 容器</span><span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>keras <span class="token keyword">import</span> layers<span class="token punctuation">,</span>Sequential<span class="token comment" spellcheck="true"># 通过Sequential 容器封装为一个网络类</span>model <span class="token operator">=</span> Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 创建隐藏层1</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 创建隐藏层2</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 创建隐藏层3</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>None<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 创建输出层</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h3 id="4-3-优化目标"><a href="#4-3-优化目标" class="headerlink" title="4.3 优化目标"></a>4.3 优化目标</h3><p>神经网络从输入到输出的计算过程叫做前向传播(Forward Propagation)或前向计算。神经网络的前向传播过程，也是数据张量(Tensor)从第一层流动(Flow)至输出层的过程，即从输入数据开始，途径每个隐藏层，直至得到输出并计算误差，这也是TensorFlow框架名字由来。</p><p>前向传播的最后一步就是完成误差的计算：<br>$$<br>ℒ = 𝑔(𝑓<em>𝜃(𝒙), 𝒚)<br>$$<br>其中𝑓<sub>𝜃</sub>(∙)代表了利用𝜃参数化的神经网络模型，𝑔(∙)称之为误差函数，用来描述当前网络的预测值𝑓<sub>𝜃</sub>(𝒙)与真实标签𝒚之间的差距度量，比如常用的均方差误差函数。ℒ称为网络的误差(Error，或损失Loss)，一般为标量。我们希望通过在训练集𝔻<sup>train</sup>上面学习到一组参数𝜃使得训练的误差ℒ最小：<br>$$<br>\theta^{*}=\underbrace{\arg \min }</em>{\theta} g\left(f_{\theta}(x), y\right), x \in \mathbb{D}^{\text {train }}<br>$$<br>上述的最小化优化问题一般采用误差反向传播(Backward Propagation，简称BP)算法来求解网络参数𝜃的梯度信息，并利用梯度下降(Gradient Descent，简称GD)算法迭代更新参数：<br>$$<br>𝜃′ = 𝜃 − 𝜂 ∙ ∇𝜃ℒ<br>$$<br>𝜂为学习率;</p><h3 id="4-4-激活函数"><a href="#4-4-激活函数" class="headerlink" title="4.4 激活函数"></a>4.4 激活函数</h3><p>下面介绍神经网络中的常见激活函数，与阶跃函数和符号函数不同，这些函数都是平滑可导的，适合于梯度下降算法。</p><p><strong>1、Sigmoid</strong>：Sigmoid 函数也叫Logistic 函数，定义为<br>$$<br>sigmoid(x) = \frac{1}{1+e^{-x}}<br>$$<br>它的一个优良特性就是能够把𝑥 ∈ 𝑅的输入“压缩”到𝑥 ∈ (0,1)区间，这个区间的数值在机器学习常用来表示以下意义：</p><ul><li>概率分布 (0,1)区间的输出和概率的分布范围[0,1]契合，可以通过Sigmoid 函数将输出转译为概率输出</li><li>信号强度 一般可以将0~1 理解为某种信号的强度，如像素的颜色强度，1 代表当前通道颜色最强，0 代表当前通道无颜色；抑或代表门控值(Gate)的强度，1 代表当前门控全部开放，0 代表门控关闭Sigmoid 函数连续可导</li></ul><p>Sigmoid 函数连续可导，可以直接利用梯度下降算法优化网络参数，应用的非常广泛。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210512210001845.png"></p><p>在 TensorFlow 中，可以通过tf.nn.sigmoid 实现Sigmoid 函数，代码如下：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过Sigmoid 函数</span></code></pre><p><strong>2、 ReLU：</strong>ReLU 函数定义为：<br>$$<br>ReLU(𝑥) ≜ max(0, 𝑥)<br>$$</p><p>可以看到，ReLU 对小于0 的值全部抑制为0；对于正数则直接输出，这种单边抑制特性来源于生物学。它具有单侧抑制、相对宽松的兴奋边界等特性</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210513182832791.png"></p><p>在 TensorFlow 中，可以通过tf.nn.relu 实现ReLU 函数，代码如下：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 通过ReLU 激活函数</span></code></pre><h3 id="4-5-输出层设计"><a href="#4-5-输出层设计" class="headerlink" title="4.5 输出层设计"></a>4.5 输出层设计</h3><p>神经网络的最后一层除了和所有的隐藏层一样，完成维度变换、特征提取的功能，还作为输出层使用，需要根据具体的任务场景来决定是否使用激活函数，以及使用什么类型的激活函数等。需要根据输出值的区间范围来分类讨论。常见的几种输出类型包括：</p><ul><li>𝑜𝑖 ∈ 𝑅𝑑 输出属于整个实数空间，或者某段普通的实数空间，比如函数值趋势的预测，年龄的预测问题等。</li><li>𝑜𝑖 ∈ [0,1] 输出值特别地落在[0, 1]的区间，如图片生成，图片像素值一般用[0, 1]区间的值表示；或者二分类问题的概率，如硬币正反面的概率预测问题。</li><li>𝑜𝑖 ∈ [0, 1], 𝑖 𝑜𝑖 = 1 输出值落在[0,1]的区间，并且所有输出值之和为1，常见的如多分类问题，如MNIST 手写数字图片识别，图片属于10 个类别的概率之和应为1。</li><li>𝑜𝑖 ∈ [−1, 1] 输出值在[-1, 1]之间</li></ul><p><strong>1、普通实数空间</strong></p><p>这一类问题比较普遍，像正弦函数曲线预测、年龄的预测、股票走势的预测等都属于整个或者部分连续的实数空间，输出层可以不加激活函数。误差的计算直接基于最后一层的输出𝒐和真实值𝒚进行计算，如采用均方差误差函数度量输出值𝒐与真实值𝒚之间的距离：<br>$$<br>ℒ = 𝑔(𝒐, 𝒚)<br>$$<br>其中𝑔代表了某个具体的误差计算函数，例如MSE 等。</p><p><strong>2 、[0, 1]区间</strong></p><p>输出值属于[0, 1]区间也比较常见，比如图片的生成、二分类问题等。在机器学习中，一般会将图片的像素值归一化到[0,1]区间，如果直接使用输出层的值，像素的值范围会分布在整个实数空间。为了让像素的值范围映射到[0,1]的有效实数空间，需要在输出层后添加某个合适的激活函数𝜎，其中Sigmoid 函数刚好具有此功能。</p><p><strong>3、 [0,1]区间，和为1</strong></p><p>输出值𝑜𝑖 ∈ [0,1]，且所有输出值之和为1，这种设定以多分类问题最为常见，输出层的每个输出节点代表了一种类别。考虑多分类问题中的样本只可能属于所有类别中的某一种，因此满足所有类别概率之和为1 的约束。</p><p>可以通过在输出层添加Softmax 函数实现。Softmax 函数定义为：<br>$$<br>Softmax(x) = \frac{e^{z_i}}{\sum_{j = 1}^{d_{out}}e^{z_j}}<br>$$<br>Softmax 函数不仅可以将输出值映射到[0,1]区间，还满足所有的输出值之和为1 的特性。</p><p>例如输出层的输出为[2.0,1.0,0.1]，经过Softmax 函数计算后，得到输出为[0.7,0.2,0.1]，每个值代表了当前样本属于每个类别的概率，概率值之和为1。通过Softmax函数可以将输出层的输出转译为类别概率，在分类问题中使用的非常频繁。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210513192502831.png"></p><p><strong>4、 [-1, 1]</strong></p><p>果希望输出值的范围分布在(−1, 1)区间，可以简单地使用tanh 激活函数，实现如下：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210513193007115.png"></p><h3 id="4-6-误差计算"><a href="#4-6-误差计算" class="headerlink" title="4.6 误差计算"></a>4.6 误差计算</h3><p>在搭建完模型结构后，下一步就是选择合适的误差函数来计算误差。常见的误差函数有均方差、交叉熵、KL 散度、Hinge Loss 函数等，其中均方差函数和交叉熵函数在深度学习中比较常见，均方差函数主要用于回归问题，交叉熵函数主要用于分类问题。</p><p><strong>1、均方差误差函数：</strong></p><p>均方差(Mean Squared Error，简称MSE)误差函数把输出向量和真实向量映射到笛卡尔坐标系的两个点上，通过计算这两个点之间的欧式距离(准确地说是欧式距离的平方)来衡量两个向量之间的差距：<br>$$<br>\operatorname{MSE}(\boldsymbol{y}, \boldsymbol{o}) \triangleq \frac{1}{d_{\text {out }}} \sum_{i=1}^{d_{\text {out }}}\left(y_{i}-o_{i}\right)^{2}<br>$$<br>MSE 误差函数的值总是大于等于0，当MSE 函数达到最小值0 时，输出等于真实标签，此时神经网络的参数达到最优状态。</p><p>均方差误差函数广泛应用在回归问题中，实际上，分类问题中也可以应用均方差误差函数。在TensorFlow 中，可以通过函数方式或层方式实现MSE 误差计算。例如，使用函数方式实现MSE 计算，代码如下：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210513194833853.png"></p><h2 id="第五章-反向传播算法"><a href="#第五章-反向传播算法" class="headerlink" title="第五章 反向传播算法"></a>第五章 反向传播算法</h2><p>误差反向传播算法（Backpropagation，简称BP），反向传播算法和梯度下降算法是神经网络的核心算法，深刻理解其工作原理十分重要。先回顾导数、梯度等数学概念，然后推导常用激活函数、损失函数的梯度形式，并开始逐渐推导感知机、多层神经网络的梯度传播方式。</p><h3 id="5-1-导数与梯度"><a href="#5-1-导数与梯度" class="headerlink" title="5.1 导数与梯度"></a>5.1 导数与梯度</h3><p>导数（Derivative）的定义是自变量𝑥产生一个微小扰动Δ𝑥后，函数输出值的增量Δ𝑦与自变量增量Δ𝑥的比值在Δ𝑥趋于0 时的极限𝑎，如果存在，𝑎即为在𝑥处的导数：<br>$$<br>a = \lim_{\Delta x \rightarrow 0} {\frac{f(x+\Delta x)-f(x)}{\Delta x}}<br>$$<br>函数的导数可以记为𝑓′(𝑥)或$\frac {d𝑦}{d𝑥}$，从几何角度来看，一元函数在某处的导数就是函数的切线在此处的斜率，即函数值沿着𝑥方向的变化率。</p><p>针对多元函数而言，当函数的自变量数大于一个时，函数的导数概念拓展为函数值沿着任意Δ𝒙方向的变化率。导数本身是标量，没有方向，但是导数表征了函数值在某个方向Δ𝒙的上变化率。在这些任意Δ𝒙方向中，沿着坐标轴的几个方向比较特殊，此时的导数也叫作偏导数（Partial Derivative）。对于多元函数的偏导数，记为$\frac{\partial y}{\partial x_{1}}, \frac{\partial y}{\partial x_{2}}, \cdots$</p><p>例如本质上为多元函数的神经网络模型，shape 为[784, 256]的权值矩阵𝑾，它包含了784 × 256个连接权值𝑤，需要求出784 × 256个偏导数。需要注意的是，在数学表达习惯中，一般要讨论的自变量记为𝒙，但是在神经网络中，𝒙一般用来表示输入，比如图片、文本、语音数据等，网络的自变量是网络参数集𝜃 = {𝑤1, 𝑏1, 𝑤2, 𝑏2, ⋯ }。利用梯度下降算法优化网络时，需要求出网络的所有偏导数。因此，我们关心的也是误差函数输出ℒ沿着自变量𝜃𝑖方向上的导数，即ℒ对网络参数𝜃𝑖的偏导数$\frac{\partial l}{\partial w_1}, \frac{\partial l}{\partial b_2}, \cdots$  等。把函数所有偏导数写成向量形式：<br>$$<br>\nabla_{\theta} \mathcal{L}=\left(\frac{\partial \mathcal{L}}{\partial \theta_{1}}, \frac{\partial \mathcal{L}}{\partial \theta_{2}}, \frac{\partial \mathcal{L}}{\partial \theta_{3}}, \cdots, \frac{\partial \mathcal{L}}{\partial \theta_{n}}\right)<br>$$<br>此时梯度下降算法可以按着向量形式进行更新：<br>$$<br>\theta^{\prime}=\theta-\eta \cdot \nabla_{\theta} \mathcal{L}<br>$$<br>𝜂为学习率超参数。梯度下降算法一般是寻找函数ℒ的最小值，有时也希望求解函数的最大值，如强化学习中希望最大化回报函数，则可按着梯度方向更新：<br>$$<br>\theta^{\prime}=\theta+\eta \cdot \nabla_{\theta} \mathcal{L}<br>$$<br>这种更新方式称为梯度上升算法。梯度下降算法和梯度上升算法思想上是相同的，一是朝<br>着梯度的反向更新，一是朝着梯度的方向更新，两者都需要求解偏导数。这里把向量<br>($\frac{\partial l}{\partial \theta_1}, \frac{\partial l}{\partial \theta_2}, \cdots \frac{\partial l}{\partial \theta_n}$  )称为函数的梯度（Gradient）。</p><p>但是通过梯度下降算法并不能保证得到全局最优解，这主要是目标函数的非凸性造成的。如图所示，深蓝色区域为极小值区域，不同的优化轨迹可能得到不同的最优数值解，这些数值解并不一定是全局最优解。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210526130047428.png"></p><blockquote><p>神经网络的模型表达式通常非常复杂，模型参数量可达千万、数亿级别，几乎所有的神经网络的优化问题都是依赖于深度学习框架去自动计算网络参数的梯度，然后采用梯度下降算法循环迭代优化网络的参数直至性能满足需求。深度学习框架这里主要实现的算法就是反向传播算法和梯度下降算法，因此理解这两个算法的原理有利于了解深度学习框架的作用。</p></blockquote><h3 id="5-2-激活函数导数"><a href="#5-2-激活函数导数" class="headerlink" title="5.2 激活函数导数"></a>5.2 激活函数导数</h3><p>Sigmoid函数表达式：$$\sigma(x) = \frac{1}{1 + e^{-x}}$$</p><p>Sigmoid函数的导数表达式：</p><p>$$<br>\begin{array}{c}<br>\frac{\mathrm{d}}{\mathrm{d} x} \sigma(x)=\frac{\mathrm{d}}{\mathrm{d} x}\left(\frac{1}{1+e^{-x}}\right) \<br>=\frac{\mathrm{e}^{-x}}{\left(1+\mathrm{e}^{-x}\right)^{2}} \<br>=\frac{\left(1+\mathrm{e}^{-x}\right)-1}{\left(1+\mathrm{e}^{-x}\right)^{2}} \<br>=\frac{1+e^{-x}}{\left(1+e^{-x}\right)^{2}}-\left(\frac{1}{1+e^{-x}}\right)^{2} \<br>=\sigma(x)-\sigma(x)^{2} \<br>=\sigma(1-\sigma)<br>\end{array}<br>$$</p><p>可以看到，Sigmoid 函数的导数表达式最终可以表达为激活函数的输出值的简单运算，利用这一性质，在神经网络的梯度计算中，通过缓存每层的Sigmoid 函数输出值，即可在需要的时候计算出其导数。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 实现 sigmoid 函数</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">sigmoid_derivative</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># sigmoid 导数的计算</span>    <span class="token comment" spellcheck="true"># sigmoid 函数的表达式由手动推导而得</span>    <span class="token keyword">return</span> sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20210527211709757.png"></p><p> ReLU 函数的导数表达式：$ReLU(𝑥) = max(0, 𝑥)$</p><p>它的导数推导非常简单，直接可得：<br>$$<br>\frac{\mathrm{d}}{\mathrm{d} x} \operatorname{ReLU}=\left{\begin{array}{ll}<br>1 &amp; x \geq 0 \<br>0 &amp; x&lt;0<br>\end{array}\right.<br>$$<br>可以看到，ReLU 函数的导数计算简单，x 大于等于零的时候，导数值恒为1，在反向传播过程中，它既不会放大梯度，造成梯度爆炸(Gradient exploding)现象；也不会缩小梯度，造成梯度弥散(Gradient vanishing)现象。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">relu</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">relu_derivative</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># ReLU 函数的导数</span>    d <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>x<span class="token punctuation">,</span> copy<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 用于保存梯度的张量</span>    d<span class="token punctuation">[</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># 元素为负的导数为 0</span>    d<span class="token punctuation">[</span>x <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 元素为正的导数为 1</span>    <span class="token keyword">return</span> d</code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210527211931148.png"></p><p>在 ReLU 函数被广泛应用之前，神经网络中激活函数采用Sigmoid 居多，但是Sigmoid函数容易出现梯度弥散现象，当网络的层数增加后，较前层的参数由于梯度值非常微小，参数长时间得不到有效更新，无法训练较深层的神经网络，导致神经网络的研究一直停留在浅层。</p><p>Tanh 函数梯度：tanh 函数的表达式：<br>$$<br>\begin{array}{l}<br>\tanh (x)=\frac{\left(e^{x}-e^{-x}\right)}{\left(e^{x}+e^{-x}\right)} \<br>=2 \cdot \operatorname{sigmoid}(2 x)-1<br>\end{array}<br>$$<br>它的导数推导为:<br>$$<br>\begin{aligned}<br>\frac{\mathrm{d}}{\mathrm{d} x} \tanh (x)=&amp; \frac{\left(e^{x}+e^{-x}\right)\left(e^{x}+e^{-x}\right)-\left(e^{x}-e^{-x}\right)\left(e^{x}-e^{-x}\right)}{\left(e^{x}+e^{-x}\right)^{2}} \<br>&amp;=1-\frac{\left(e^{x}-e^{-x}\right)^{2}}{\left(e^{x}+e^{-x}\right)^{2}}=1-\tanh ^{2}(x)<br>\end{aligned}<br>$$</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">tanh</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># tanh 函数实现</span>    <span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">*</span>sigmoid<span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">def</span> <span class="token function">tanh_derivative</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># tanh 导数实现</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">-</span>tanh<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span></code></pre><p><img src="C:\Users\zhou\AppData\Roaming\Typora\typora-user-images\image-20210527212906988.png"></p><h3 id="5-3-损失函数梯度"><a href="#5-3-损失函数梯度" class="headerlink" title="5.3 损失函数梯度"></a>5.3 损失函数梯度</h3><p>均方误差损失函数表达式为：$\mathcal{L}=\frac{1}{2} \sum_{k=1}^{K}\left(y_{k}-o_{k}\right)^{2}$</p><p>上式中的$\frac {1}{2}$项用于简化计算，也可以利用$\frac{1}{k}$进行平均，这些缩放运算均不会改变梯度方向。则它的偏导数$\frac {∂ℒ}{∂𝑜<em>𝑖}$可以展开为：<br>$$<br>\frac{\partial \mathcal{L}}{\partial o</em>{i}}=\frac{1}{2} \sum_{k=1}^{K} \frac{\partial}{\partial o_{i}}\left(y_{k}-o_{k}\right)^{2}<br>$$<br>利用复合函枚导数法则分解为:<br>$$<br>\frac{\partial \mathcal{L}}{\partial \boldsymbol{o}<em>{\boldsymbol{i}}}=\frac{1}{2} \sum</em>{k=1}^{K}{ }<em>{k=1} \cdot\left(y</em>{k}-o_{k}\right) \cdot \frac{\partial\left(y_{k}-o_{k}\right)}{\partial o_{i}}<br>$$<br>即<br>$$<br>\begin{aligned}<br>\frac{\partial \mathcal{L}}{\partial o_{i}} &amp;=\sum_{k=1}^{K}\left(y_{k}-o_{k}\right) \cdot-1 \cdot \frac{\partial o_{k}}{\partial o_{i}} \<br>&amp;=\sum_{k=1}^{K}\left(o_{k}-y_{k}\right) \cdot \frac{\partial o_{k}}{\partial o_{l}}<br>\end{aligned}<br>$$<br>考虑到$\frac {𝜕𝑜<em>𝑘}{𝜕𝑜_𝑖}$仅当𝑘 = 𝑖时才为1，其它点都为0，也就是说，偏导数$\frac {𝜕ℒ}{𝜕𝑜𝑖}$只与第𝑖号节点相关，与其它节点无关，因此上式中的求和符号可以去掉。均方误差函数的导数可以推导为：<br>$$<br>\frac{\partial \mathcal{L}}{\partial o</em>{i}}=\left(o_{i}-y_{i}\right)<br>$$</p><h3 id="5-4-全连接层梯度"><a href="#5-4-全连接层梯度" class="headerlink" title="5.4 全连接层梯度"></a>5.4 全连接层梯度</h3><p>单神经元梯度：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210604094102790.png"></p><p>如果我们采用均方误差函数，考虑到单个神经元只有一个输出𝑜<sub>1</sub><sup>(1)</sup>，那么损失可以表达为：<br>$$<br>L =\frac{1}{2}(o_1^{(1)}-t)^2 = (o_1-t)^2<br>$$<br>其中𝑡为真实标签值，添加$\frac{1}{2}$并不影响梯度的方向，计算更简便。我们以权值连接的第𝑗 ∈[1,j]号节点的权值变量𝑤<sub>j1</sub>为例，考虑损失函数ℒ对其的偏导数$\frac{\partial \mathcal{L}}{\partial w_{j1}}$<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{j1}} = (o_1-t)\frac{\partial \mathcal{o_1}}{\partial w_{j1}}<br>$$</p><p>全连接层梯度:把单个神经元模型推广到单层的全连接层的网络上，输入层通过一个全连接层得到输出向量𝒐(1)，与真实标签向量𝒕计算均方误差。输入节点数为J，输出节点数为𝐾。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210604101535767.png"></p><p>多输出的全连接网络层模型与单个神经元模型不同之处在于，它多了很多的输出节点𝑜<sub>1</sub><sup>(1)</sup>, 𝑜<sub>2</sub><sup>(1)</sup>,, 𝑜<sub>3</sub><sup>(1)</sup>,, ⋯ , 𝑜<sub>k</sub><sup>(1)</sup>,，每个输出节点分别对应到真实标签𝑡<sub>1</sub>, 𝑡<sub>2</sub>, … , 𝑡<sub>k</sub>。𝑤<sub>k</sub>是输入第𝑗好节点与输出第𝑘号节点的连接权值。均方误差可以表达为：<br>$$<br>L=\frac{1}{2} \sum_{k=1}^{K} \left(o_{i}^{(1)}-t_{i}\right)^{2}<br>$$<br>这里简单使用TensorFlow 自动求导功能，来体验链式法则求解全连接层梯度的魅力。例如：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token comment" spellcheck="true"># 构建待优化变量</span>x <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span>w1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">)</span>b1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span>w2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">)</span>b2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 构建梯度记录器</span><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span>persistent<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 非tf.Variable 类型的张量需要人为设置记录梯度信息</span>    tape<span class="token punctuation">.</span>watch<span class="token punctuation">(</span><span class="token punctuation">[</span>w1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> w2<span class="token punctuation">,</span> b2<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 构建2 层线性网络</span>    y1 <span class="token operator">=</span> x <span class="token operator">*</span> w1 <span class="token operator">+</span> b1    y2 <span class="token operator">=</span> y1 <span class="token operator">*</span> w2 <span class="token operator">+</span> b2<span class="token comment" spellcheck="true"># 独立求解出各个偏导数</span>dy2_dy1 <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>y2<span class="token punctuation">,</span> <span class="token punctuation">[</span>y1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>dy1_dw1 <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>y1<span class="token punctuation">,</span> <span class="token punctuation">[</span>w1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>dy2_dw1 <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>y2<span class="token punctuation">,</span> <span class="token punctuation">[</span>w1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 验证链式法则，2 个输出应相等</span><span class="token keyword">print</span><span class="token punctuation">(</span>dy2_dy1 <span class="token operator">*</span> dy1_dw1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>dy2_dw1<span class="token punctuation">)</span></code></pre><p>以上代码，通过自动求导功能计算出$\frac{\partial \mathcal{y_2}}{\partial y_1},\frac{\partial \mathcal{y_1}}{\partial w_1}和\frac{\partial \mathcal{y_2}}{\partial w_1}$，借助链式法则我们可以推断$\frac{\partial \mathcal{y_2}}{\partial y_1},\frac{\partial \mathcal{y_1}}{\partial w_1}和\frac{\partial \mathcal{y_2}}{\partial w_1}$应该是相等的，它们的计算结果如下：</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>float32<span class="token punctuation">)</span>tf<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>float32<span class="token punctuation">)</span></code></pre><p>可以看到$\frac{\partial \mathcal{y_2}}{\partial y_1},\frac{\partial \mathcal{y_1}}{\partial w_1}和\frac{\partial \mathcal{y_2}}{\partial w_1}$，偏导数的传播是符合链式法则的。</p><h3 id="5-5-反向传播算法"><a href="#5-5-反向传播算法" class="headerlink" title="5.5 反向传播算法"></a>5.5 反向传播算法</h3><p>现在来推导隐藏层的梯度传播规律。简单回顾一下输出层的偏导数公式：<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{j k}}=\left(o_{k}-t_{k}\right) o_{k}\left(1-o_{k}\right) x_{j}=\delta_{k} x_{j}<br>$$<br>考虑倒数第二层的偏导数 $\frac{\partial \mathcal{L}}{\partial w_{i j}}$, 输出层节点数为 K，输出为 $\boldsymbol{0}^{(K)}=\left[o_{1}^{(K)}, o_{2}^{(K)}, \cdots, o_{K}^{(K)}\right] $ ；倒数第二层节点数为 $\mathrm{J}$, 输出为 $\boldsymbol{o}^{(J)}=\left[o_{1}^{(J)}, o_{2}^{(I)}, \cdots, o_{J}^{(J)}\right] $； 倒数第三层的节点数为 $\mathrm{I}$, 输出为 $\boldsymbol{o}^{(I)}=\left[o_{1}^{(I)}, o_{2}^{(I)}, \cdots, o_{I}^{(I)}\right] $。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210604103815539.png"></p><p>由于 $\mathcal{L}$ 通过每个输出节点o $<em>{k}$ 与 $w</em>{i j}$ 相关联，故此处不能去掉求和符号，运用链式法则将均方 差函数拆解：<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\sum_{k}\left(o_{k}-t_{k}\right) \frac{\partial}{\partial w_{i j}} o_{k}<br>$$<br>将o $<em>{k}=\sigma\left(z</em>{k}\right)$ 代入可得:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\sum_{k}\left(o_{k}-t_{k}\right) \frac{\partial}{\partial w_{i j}} \sigma\left(z_{k}\right)<br>$$<br>利用 Sigmoid 函数的导数 $\sigma^{\prime}=\sigma(1-\sigma)$ 进一步分解为:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\sum_{\boldsymbol{k}}\left(o_{k}-t_{k}\right) \sigma\left(z_{k}\right)\left(1-\sigma\left(z_{k}\right)\right) \frac{\partial z_{k}}{\partial w_{i j}}<br>$$<br>将 $\sigma\left(z_{k}\right)$ 写回 $o_{k}$ 形式，并利用链式法则，将 $\frac{\partial z_{k}}{\partial w_{i j}}$ 分解为:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\sum_{k}\left(o_{k}-t_{k}\right) o_{k}\left(1-o_{k}\right) \frac{\partial z_{k}}{\partial o_{j}} \cdot \frac{\partial o_{j}}{\partial w_{i j}}<br>$$<br>中 $\frac{\partial z_{k}}{\partial o_{j}}=w_{j k}$, 因此:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\sum_{k}\left(o_{k}-t_{k}\right) o_{k}\left(1-o_{k}\right) w_{j k} \frac{\partial o_{j}}{\partial w_{i j}}<br>$$<br>考虑到 $\frac{\partial o_{j}}{\partial w_{i j}}$ 与 $k$ 无关，可提取公共项为:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\frac{\partial o_{j}}{\partial w_{i j}} \sum_{k}\left(o_{k}-t_{k}\right) o_{k}\left(1-o_{k}\right) w_{j k}<br>$$<br>进一步利用o $<em>{j}=\sigma\left(z</em>{j}\right)$, 并利用 Sigmoid 导数 $\sigma^{\prime}=\sigma(1-\sigma)$, 将 $\frac{\partial o_{j}}{\partial w_{i j}}$ 拆分为<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=o_{j}\left(1-o_{j}\right) \frac{\partial z_{j}}{\partial w_{i j}} \sum_{k}\left(o_{k}-t_{k}\right) o_{k}\left(1-o_{k}\right) w_{j k}<br>$$<br>其中 $\frac{\partial z_{j}}{\partial w_{i j}}$ 的导数可直接推导出为 $o_{i}$, 上式可写为:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=o_{j}\left(1-o_{j}\right) o_{i} \sum_{k} \underbrace{\left(o_{k}-t_{k}\right) o_{k}\left(1-o_{k}\right)}<em>{\delta</em>{k}^{(K)}} w_{j k}<br>$$<br>其中 $\delta_{k}^{(K)}=\left(o_{k}-t_{k}\right) o_{k}\left(1-o_{k}\right)$, 则 $\frac{\partial \mathcal{L}}{\partial w_{i j}}$ 的表达式可简写为:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=o_{j}\left(1-o_{j}\right) o_{i} \sum_{\mathrm{k}} \delta_{k}^{(K)} w_{j k}<br>$$<br>类似地，仿照输出层$\frac{\partial \mathcal{L}}{\partial w_{j k}} =\delta_{k}^{(K)} x_{j}$ 的书写方式，将 $\delta_{j}^{J}$ 定义为:<br>$$<br>\delta_{j}^{J} \triangleq o_{j}\left(1-o_{j}\right) \sum_{k} \delta_{k}^{(K)} w_{j k}<br>$$<br>此时 $\frac{\partial \mathcal{L}}{\partial w_{i j}}$ 可以写为当前连接的起始节点的输出值o $<em>{i}$ 与终止节点j的梯度变量信息 $\delta</em>{j}^{(J)}$ 的简单相<br>乘运算:<br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\delta_{j}^{(J)} o_{i}^{(I)}<br>$$<br><strong>输出层:</strong><br>$$<br>\begin{array}{c}<br>\frac{\partial \mathcal{L}}{\partial w_{j k}}=\delta_{k}^{(K)} o_{j} \<br>\delta_{k}^{(K)}=o_{k}\left(1-o_{k}\right)\left(o_{k}-t_{k}\right)<br>\end{array}<br>$$<br><strong>倒数第二层:</strong><br>$$<br>\frac{\partial \mathcal{L}}{\partial w_{i j}}=\delta_{j}^{(J)} o_{i}<br>$$<br>$$<br>\delta_{j}^{(J)}=o_{j}\left(1-o_{j}\right) \sum_{k} \delta_{k}^{(K)} w_{j k}<br>$$<br><strong>倒数第三层:</strong><br>$$<br>\begin{array}{c}<br>\frac{\partial \mathcal{L}}{\partial w_{n i}}=\delta_{i}^{(I)} o_{n} \<br>\delta_{i}^{(I)}=o_{i}\left(1-o_{i}\right) \sum_{j} \delta_{j}^{(J)} w_{i j}<br>\end{array}<br>$$<br>其中 $o_{n}$ 为倒数第三层的输入，即倒数第四层的输出。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习中的数学原理</title>
      <link href="/2020/03/31/mathematicaofmachinelearning/"/>
      <url>/2020/03/31/mathematicaofmachinelearning/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习中的数学原理"><a href="#机器学习中的数学原理" class="headerlink" title="机器学习中的数学原理"></a>机器学习中的数学原理</h1><h2 id="第一讲-微积分和梯度"><a href="#第一讲-微积分和梯度" class="headerlink" title="第一讲 微积分和梯度"></a>第一讲 微积分和梯度</h2><p>主要内容</p><ul><li>常数e的计算过程</li><li>常见函数的导数</li><li>分部积分法及其应用</li><li>梯度</li><li>上升/下降最快方向</li><li>凸函数</li><li>Jensen不 等式</li></ul><h3 id="1、极限"><a href="#1、极限" class="headerlink" title="1、极限"></a>1、极限</h3><p>例如：求S的值：</p><p>​    $S=\frac{1}{0 !}+\frac{1}{1 !}+\frac{1}{2 !}+\frac{1}{3 !}+\frac{1}{4 !}+\cdots+\frac{1}{n !}+\cdots$</p><p>==夹逼定理==</p><blockquote><p> 在某-域上,若9(x)≤f(x)≤h(x),同时我们还知道， 当x趋向a时，9(x)的极限<br> 等于L，以及当x趋向a时，h(x)的极限也等于L，那么夹逼定理告诉我们:当x趋向a时，f(x)的极限也一 定等于L。</p></blockquote><p>可以求出对数函数的上升速度：</p><p>问题分析：令f(x)= log<sub>a</sub>X,则:<br>$$<br>\begin{aligned}<br>&amp;\frac{f(x+\Delta x)-f(x)}{\Delta x}=\frac{\log _{a}(x+\Delta x)-\log _{a} x}{\Delta x}=\frac{\log _{a}\left(\frac{x+\Delta x}{x}\right)}{\Delta x}=\log _{a}\left(\frac{x+\Delta x}{x}\right)^{\frac{1}{\Delta x}}<br>\end{aligned}<br>$$<br>$$<br>\stackrel{\because x=1}{\longrightarrow} \log _{a}(1+\Delta x)^{\frac{1}{\Delta x}}=1 \Rightarrow \lim _{\Delta x \rightarrow 0}(1+\Delta x)^ \frac{1}{\Delta x}=a<br>$$</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> math<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span> pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npx <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0.05</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0.05</span><span class="token punctuation">)</span>y1<span class="token operator">=</span><span class="token punctuation">[</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> a <span class="token keyword">in</span> x<span class="token punctuation">]</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'#007500'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'log1.5(x)'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>y1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"r--"</span><span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>y2 <span class="token operator">=</span> <span class="token punctuation">[</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> a <span class="token keyword">in</span> x<span class="token punctuation">]</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'#9F35FF'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'log2(x)'</span><span class="token punctuation">)</span>y3 <span class="token operator">=</span> <span class="token punctuation">[</span>math<span class="token punctuation">.</span>log<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">for</span> a <span class="token keyword">in</span> x<span class="token punctuation">]</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y3<span class="token punctuation">,</span> linewidth<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'#F75000'</span> <span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'1og3(x)'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span> legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'lower right'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span> grid<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'./test.jpg'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span> show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/test.jpg"></p><p>问：<br>$$<br>\lim _{n \rightarrow \infty}\left(1+\frac{1}{n}\right)^{n}=?<br>$$<br>显然：由高度数学可知：<br>$$<br>\lim _{n \rightarrow \infty}\left(1+\frac{1}{n}\right)^{n}=e<br>$$</p><p>推到过程：<br>$$<br>\begin{array}{l}<br>x_{n}=\left(1+\frac{1}{n}\right)^{n} \<br>=1+C_{n}^{1} \frac{1}{n}+C_{n}^{2} \frac{1}{n^{2}}+C_{n}^{3} \frac{1}{n^{3}}+\cdots+C_{n}^{n} \frac{1}{n^{n}} \<br>=1+n \cdot \frac{1}{n}+\frac{n(n-1)}{2 !} \cdot \frac{1}{n^{2}}+\frac{n(n-1)(n-2)}{3 !} \cdot \frac{1}{n^{3}}+\cdots+\frac{n(n-1)(n-2) \cdots 1}{n !} \cdot \frac{1}{n^{n}} \<br>=1+1+\frac{1}{2 !} \cdot\left(1-\frac{1}{n}\right)+\frac{1}{3 !} \cdot\left(1-\frac{1}{n}\right)\left(1-\frac{2}{n}\right)+\cdots+\frac{1}{n !} \cdot\left(1-\frac{1}{n}\right)\left(1-\frac{2}{n}\right) \cdots\left(1-\frac{n-1}{n}\right)<br>&lt;1+1+\frac{1}{2 !}+\frac{1}{3 !}+\cdots+\frac{1}{n !} \<br>&lt;1+1+\frac{1}{2}+\frac{1}{2^{2}}+\cdots+\frac{1}{2^{n-1}} \<br>=3-\frac{1}{2^{n-1}} \<br>&lt;3<br>\end{array}<br>$$</p><p>由此，{<em>Xn</em>}是有上界的。<br>$$<br>x_{n+1}-x_{n}&gt;\frac{1}{(n+1)} \cdot\left(1-\frac{1}{n+1}\right)\left(1-\frac{2}{n+1}\right) \cdots\left(1-\frac{n}{n+1}\right)&gt;0<br>$$<br>由此，{<em>Xn</em>}是单增的。</p><p>根据极限存在定义；这个极限一定是存在的。而且这是数大于2小于3。故而。我们将这个数记为:e</p><p>==自然常数：==$\lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^{x}=e$</p><p>根据前文      $a_{n}=\left(1+\frac{1}{n}\right)^{n}$中的二项展开式，已经证明数组{a<sub>n</sub>}单增有上界，因此，必有极限，记做e。对实数x，总存在整数n，使得n≤x≤n+1，得:<br>$$<br>\begin{array}{c}<br>\left(1+\frac{1}{n+1}\right)^{n}&lt;\left(1+\frac{1}{x}\right)^{x}&lt;\left(1+\frac{1}{n}\right)^{n+1} \<br>\lim _{n \rightarrow \infty}\left(1+\frac{1}{n+1}\right)^{n}=\lim _{n \rightarrow \infty} \frac{\left(1+\frac{1}{n+1}\right)^{n+1}}{1+\frac{1}{n+1}}=\frac{\lim _{n \rightarrow \infty}\left(1+\frac{1}{n+1}\right)^{n+1}}{\lim _{n \rightarrow \infty}\left(1+\frac{1}{n+1}\right)}=\frac{e}{1+0}=e \<br>\lim _{n \rightarrow \infty}\left(1+\frac{1}{n}\right)^{n+1}=\lim _{n \rightarrow \infty}\left(\left(1+\frac{1}{n}\right)^{n}\left(1+\frac{1}{n}\right)\right)=\lim _{n \rightarrow \infty}\left(1+\frac{1}{n}\right)^{n} \cdot \lim _{n \rightarrow \infty}\left(1+\frac{1}{n}\right)=e \cdot(1+0)=e<br>\end{array}<br>$$<br>根据夹逼定理，函数$f(x)=\left(1+\frac{1}{x}\right)^{x}$的极限必然存在且为e。</p><h3 id="2、导数"><a href="#2、导数" class="headerlink" title="2、导数"></a>2、导数</h3><p>简单的说，导数就是曲线的斜率，是曲线变化快慢的反应。二阶导数是斜率变化快慢的反应，表征曲线凸凹性。二阶导数连续的曲线，往往称之为“光顺”的。还记得高中物理老师时常念叨的吗:加速度的方向总是<br>指向轨迹曲线凹的一侧。根据$\lim _{x \rightarrow \infty}\left(1+\frac{1}{x}\right)^{x}=e$可以得到函数$f(x)=\ln x$的导数，进一步根据换底公式、反函数求导等，得到其他初等函数的导数。<br>$$<br>\begin{array}{cc}<br>C^{\prime}=0 &amp; \left(x^{n}\right)^{\prime}=n x^{n-1} \<br>(\sin x)^{\prime}=\cos x &amp; (\cos x)^{\prime}=-\sin x \<br>\left(a^{x}\right)^{\prime}=a^{x} \ln a &amp; \left(e^{x}\right)^{\prime}=e^{x} \<br>\left(\log _{a} x\right)^{\prime}=\frac{1}{x} \log _{a} e &amp; (\ln x)^{\prime}=\frac{1}{x} \<br>(u+v)^{\prime}-u^{\prime}+v^{\prime} &amp; (u v)^{\prime}=u^{\prime} v+u v^{\prime}<br>\end{array}<br>$$<br>掌握高等数学中的分部积分法、凑微分法、换元法….<br>$$<br>N^{\frac{1}{\log N}}= ?<br>$$<br>在计算机算法跳跃表SkipList的分析中，用到了该常数。背景:跳表是支持增删改查的动态数据结构，能够达到与平衡二叉树、红黑树近似的效率，而代码实现简单。</p><p>积分应用：$N \rightarrow \infty \Rightarrow \ln N ! \rightarrow N(\ln N-1)$<br>$$<br>\begin{array}{l}<br>\ln N !=\sum_{i=1}^{N} \ln i \approx \int_{1}^{N} \ln x d x \<br>=\left.x \ln x\right|<em>{1} ^{N}-\int</em>{1}^{N} x d \ln x \<br>=N \ln N-\int_{1}^{N} \quad x \cdot \frac{1}{x} d x \<br>=N \ln N-\left.x\right|_{1} ^{N} \<br>=N \ln N-N+1 \<br>\rightarrow N \ln N-N<br>\end{array}<br>$$</p><h3 id="3、方向导数"><a href="#3、方向导数" class="headerlink" title="3、方向导数"></a>3、方向导数</h3><p>如果函数Z=f(x，y)在点P(x,y)是可微分的，那么，函数在该点沿任一方向L的方向导数都存在，且有:<br>$$<br>\frac{\partial f}{\partial l}=\frac{\partial f}{\partial x} \cos \varphi+\frac{\partial f}{\partial y} \sin \varphi<br>$$<br>其中,ψ为x轴到方向L的转角。</p><h3 id="4、梯度"><a href="#4、梯度" class="headerlink" title="4、梯度"></a>4、梯度</h3><p>设函数z=f(x,y)在平面区域D内具有一阶连续偏导数，则对于每一个点P(x,y)∈D，向量</p><p>$\left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)$</p><p>为函数z=f(x,y)在点P的梯度，记做gradf(x,y)。梯度的方向是函数在该点变化最快的方向</p><h3 id="5、凸函数"><a href="#5、凸函数" class="headerlink" title="5、凸函数"></a>5、凸函数</h3><p>若函数f的定义域domf为凸集，且满足：<br>$$<br>\begin{array}{l}<br>\forall x, y \in \operatorname{dom} f, 0 \leq \theta \leq 1, \text { 有 } \<br>f(\theta x+(1-\theta) y) \leq \theta f(x)+(1-\theta) f(y)<br>\end{array}<br>$$<br><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210401105231130.png"></p><p>==注：在机器学习中，凸函数和凹函数的定义与高等数学相反==</p><p>若f一阶可微，则函数f为凸函数当前仅当f的定义域domf为凸集，且<br>$$<br>\forall x, y \in \operatorname{dom} f, f(y) \geq f(x)+\nabla f(x)^{T}(y-x)<br>$$<br><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210401105748209.png"></p><p>结合凸函数图像和支撑超平面理解该问题。对于凸函数，其一阶Taylor近似本质上是该<br>函数的全局下估计。反之，如果一个函数的一阶Taylor近似总是起全局下估计，则该函数是凸函数。<br>该不等式说明从一个函数的局部信息，可以得到一定程度的全局信息。与机器学习领域中的凸优化相联系。</p><h3 id="6、Jensen不等式"><a href="#6、Jensen不等式" class="headerlink" title="6、Jensen不等式"></a>6、Jensen不等式</h3><p>若f是凸函数：$f(\theta x+(1-\theta) y) \leq \theta f(x)+(1-\theta) f(y)$</p><p>若 $\theta_{1}, \ldots, \theta_{k} \geq 0, \theta_{1}+\cdots+\theta_{k}=1$，则 $f\left(\theta_{1} x_{1}+\cdots+\theta_{k} x_{k}\right) \leq \theta_{1} f\left(x_{1}\right)+\cdots+\theta_{k} f\left(x_{k}\right)$</p><p>若 $p(x) \geq 0$ on $S \subseteq \operatorname{dom} f, \int_{S} p(x) d x=1$，则 $f\left(\int_{S} p(x) x d x\right) \leq \int_{S} f(x) p(x) d x$</p><blockquote><p>可以推导得出：$f(\mathbf{E} x) \leq \mathbf{E} f(x)$</p></blockquote><p>Jensen不等式是几乎所有不等式的基础，例如：利用y=-logx是凸函数，证明:$\frac{a+b}{2} \geq \sqrt{a b}, \quad a&gt;0, b&gt;0$<br>提示:任取a,b&gt;0，θ=0.5带入 基本Jensen不等式，利用f(E(x))≤E(f(x))，(f是 凸函数)，证明下式D≥0<br>$$<br>D(p | q)=\sum_{x} p(x) \log \frac{p(x)}{q(x)}=E_{p(x)} \log \frac{p(x)}{q(x)}&gt;0<br>$$<br><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210401110909370.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于机器视觉的机械手掌</title>
      <link href="/2020/03/07/ji-yu-ji-qi-shi-jue-de-fang-sheng-ji-jie-shou-zhang/"/>
      <url>/2020/03/07/ji-yu-ji-qi-shi-jue-de-fang-sheng-ji-jie-shou-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="基于机器视觉的机械手掌"><a href="#基于机器视觉的机械手掌" class="headerlink" title="基于机器视觉的机械手掌"></a>基于机器视觉的机械手掌</h1><p>将完成机械手掌的结构设计、舵机控制板设计、嵌入式软件设计、深度学习算法设计、数字图像预处理算法设计。本组使用一种常见的带掌连杆传动机械手，在舵机控制板的设计中采用以STM32F103系列的MCU六路舵机控制器。本组对舵机控制系统进行建模，采用PID控制算法对舵机进行控制，将 PID算法部署在STM32单片机上，采用C语言实现PID算法。在深度学习算法方面，通过摄像头采集手势图像，所采集的图像先由OpenCV完成图像预处理，再将预处理完成的图片输入TensorFlow框架搭建的卷积神经网络用以分类图像，实现目标手势与模型匹配。在25ms内识别手势图片，在50ms内实现出拳动作，由此实现了用户手势和机械手掌的手势之间实时猜拳互动，达到了很好的效果。</p><iframe src="//player.bilibili.com/player.html?aid=886981603&bvid=BV1hK4y1J7gP&cid=304571731&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="一、总体技术路线"><a href="#一、总体技术路线" class="headerlink" title="一、总体技术路线"></a>一、总体技术路线</h2><p>机械手的总体设计包括机械结构、硬件电路、机器视觉领域的图像分类算法设计以及舵机控制算法设计四个部分。本章将对机械手掌的总体设计方案进行简要的概括。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310103941740.png" alt="总体示意图"></p><p>首先第一部分是通过OpenCV进行图像预处理，这个过程是先把摄像头采集到的图像由RGB空间转换到HSV空间（HSV空间对用户来说是一种直观的颜色模型），再把图像二值化转成灰度图，提取主要特征得到目标轮廓；另一部分是在树莓派上搭建一个应用以卷积神经网络为核心的图像分类深度学习模型。</p><p>完成这两部份工作以后，将预处理后的图像与搭建好的模型对比进行匹配，接着通过串口通信将匹配结果转换成相应的舵机ID号、位置信息及时间等参数指令传送到舵机控制器上，控制舵机实现相应的石头、剪刀、布的手势动作。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310104041626.png" alt="程序流程图"></p><p>​    本次设计拟达到的技术指标如下：</p><ol><li><p>识别一张图片控制在25ms以内，识别精度达到95％以上；</p></li><li><p>整体系统响应时间在40-50ms以内；</p></li><li><p>舵机控制板能提供5V/2A的带载能力，具有高压低压报警保护。</p></li></ol><h2 id="二、机械结构分析"><a href="#二、机械结构分析" class="headerlink" title="二、机械结构分析"></a>二、机械结构分析</h2><p>机械手的结构整体与人手类似，基于手指的仿生原理，本次设计将使用一种常见的带掌连杆传动机械手，包括手掌和5根手指。手指是两个四连杆机构，每根手指均只有一个自由度，而手掌板由两个相同的固定板块组成，掌心相邻手指固定部位留有间隙，便于提取电机驱动线和控制信号线，方便调试。</p><p>本次设计所用的机械手掌的机械结构除手指关节的连杆为铝合金材料以外均由亚克力材料制作，铝合金制作的连杆稳定性很好，亚克力板硬度好、美观且易加工。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310104118104.png" alt="机械手掌结构图"></p><h2 id="三、硬件电路控制板设计"><a href="#三、硬件电路控制板设计" class="headerlink" title="三、硬件电路控制板设计"></a>三、硬件电路控制板设计</h2><p>在将图像数据与实际的控制动作匹配以后，采用动态的PID算法，对五个手掌的舵机进行控制。因此，本组设计了基于STM32的舵机控制器。</p><p>此舵机控制板是内置大功率集成稳压模块，舵机口输出电压可调；6路含过载保护PWM舵机口；支持USB一键下载；支持低压报警。此控制器的主要作用是串口接收上位器（树莓派）发送的数据，将数据解析成实时控制的舵机位置信息，并操作舵机做出相应的动作。舵机控制版PCB图如图。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310104348668.png" alt="控制器PCB板"></p><p>机械手掌中五个手指由五个防堵转舵机LFD-01驱动，云台由180度的LD-1501数字舵机驱动，其原理基于直流伺服电机拖动系统。舵机是一种位置伺服的驱动器，适用于那些需要角度不断变化并能够保持的控制系统。在机械手掌的控制系统中，舵机控制效果是影响性能的重要因素。因此经过研究分析，本次设计将引入PID控制算法，大大地改善系统的性能指标，从而能够让舵机控制机械手指更好、更快、更稳地完成指定的手势动作。</p><h2 id="四、开发环境搭建"><a href="#四、开发环境搭建" class="headerlink" title="四、开发环境搭建"></a>四、开发环境搭建</h2><p>首先需安装树莓派官方系统，搭建好opencv和tensorflow开发环境；</p><p>opencv安装方法请参考：<a href="https://blog.csdn.net/leaves_joe/article/details/67656340?utm_source=app">https://blog.csdn.net/leaves_joe/article/details/67656340?utm_source=app</a></p><p>tensorflow安装方法：</p><p>首先安装pip3。</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install python3-devsudo apt-get install python-dev</code></pre><p>查看python3的版本：</p><pre class=" language-shell"><code class="language-shell">python3 -v</code></pre><p>一般树莓派4使用的是python3.7，如果网速可以，直接安装：</p><pre class=" language-shell"><code class="language-shell">sudo pip3 install tensorflow</code></pre><p>如若安装失败，则请下载本地安装包，我这使用的是tensorflow-1.13.1-cp37-none-linux_armv7l.whl，在存放这个文件的文件夹下：</p><pre class=" language-shell"><code class="language-shell">sudo pip3 install tensorflow-1.13.1-cp37-none-linux_armv7l.whl</code></pre><p>如若报错少了h5py，则请下载h5py-2.7.1-cp37-cp37m-linux_armv7l.whl，先安装h5py，再安装tensorflow:</p><pre class=" language-shell"><code class="language-shell">sudo pip3 install h5py-2.7.1-cp37-cp37m-linux_armv7l.whl</code></pre><p>在安装完opencv和tensorflow后在终端输入python3后，键入：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">print</span><span class="token punctuation">(</span>cv2<span class="token punctuation">.</span>__version__<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>__version__<span class="token punctuation">)</span></code></pre><p>如果正常打印出版本信息，则安装正确，会有警告，但无妨；</p><p>安装完环境后：</p><hr><p>—————————————————————————********<em><strong><strong><strong><strong>重点</strong></strong></strong></strong></em>——————————————————————-</p><hr><p><strong>源码详见：<a href="https://github.com/Zwyywz/Undergraduate-graduation-project">https://github.com/Zwyywz/Undergraduate-graduation-project</a></strong></p><p>最好将 树莓派4B上手势识别 这个文件夹重命名为英文，我这命名为：rps ;</p><p>在rps文件夹中新建一个文件夹 images。运行cam.py文件，会自动采集照片到images文件夹。文件名为imageX.jpg，其中X为序号。需采集“石头”“剪刀”“布”“干扰手势”，分别保存到“paper””rock””scissors””others”</p><p>model.py: 卷积神经网络模型</p><p>read_image.py:将图片读入内存</p><p>train.py:训练模型</p><p>test.py :测试手势图片识别结果</p><p>rps.py：最终完成</p><h2 id="五、STM32舵机控制"><a href="#五、STM32舵机控制" class="headerlink" title="五、STM32舵机控制"></a>五、STM32舵机控制</h2><p>主要产生五路PWM信号控制舵机，并接收串口信息。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/%E6%9C%BA%E6%A2%B0%E6%89%8B_%E9%A1%B5%E9%9D%A2_1.jpg" alt="控制器原理图"></p><p>设计的直流电源模块如图3.5所示，由JP1或者USB1输入的经过由220V变压到12V，50HZ的交流电。D3发光二极管为电源指示灯，D4发光二极管为USB供电指示灯。后接两个AMS1117模块，分别对外输出3.3V和5V，LED2为供电正常指示灯。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310104815130.png" alt="电源模块"></p><p>在此系统中，对于内存要求不高，I/O使用较少。因此我们的选择有51单片机与32单片机两种控制器。由于51单片机的部分功能限制以及为了以后可以继续开发此系统，因此选择STM32作为主控芯片。在考虑到我们所需要用到的I/O口较少，因此可以不用选择I/O较多的控制芯片，减少资源浪费以及降低成本，因此可以选择STM32ret6与STM32c8t6。这两种芯片，功能引脚都是互通的且价格相近，对比图如图3.7所示，经小组讨论选择左边的STM32ret6作为主控制器。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210310104927254.png" alt="控制器"></p><h2 id="六、串口通信"><a href="#六、串口通信" class="headerlink" title="六、串口通信"></a>六、串口通信</h2><p>由于图像分类算法对于硬件平台要求较高，需要有强大的并行计算能力。故而无法部署在单片机上。因此，本设计将上下端分离设计模式，上端是图片分类算法部署在树莓派4B上，下端是以STM32F103为核心的舵机控制器。这样设计的优点是能最大限度提高整个系统的效率，上端将图像识别的结果以指令的形式发送，下端接收到指令后进行指令解析，再控制舵机完成相应指令。</p><p>由此可以看出设计高效稳定的上下端通信协议（指令）就显得尤为重要。由设计要求可以看出：此套通信协议必须包括帧头、校验、舵机个数、某个舵机ID、控制量、反应时间等等要素。例如控制三个舵机和控制五个舵机的帧长度是不一样的。故而需要使用可变帧长度的通信协议。</p><table><thead><tr><th>帧头</th><th>数据长度</th><th>指令</th><th>参数</th></tr></thead><tbody><tr><td>0x550x55</td><td>length</td><td>Cmd</td><td>Prm1 ·····PrmN</td></tr></tbody></table><p>帧头：连续收到两个 0x55 ,表示有数据包到达。</p><p>数据长度：等于参数个数 N 加一个指令加数据长度本身占用的一个字节长度，即数据长度 Length 等于参数 N + 2, 数据长度 Length =控制舵机的个数× 3+5。</p><p>  指令：各种控制指令</p><p>  参数：除指令外需要补充的控制信息</p><p>  参数 1：要控制舵机的个数<br>         参数 2：时间低八位<br>         参数 3：时间高八位<br>         参数 4：舵机 ID 号<br>         参数 5：角度位置低八位<br>         参数 6：角度位置高八位<br>      比如控制1号舵机在1000ms内转到2000的位置，如表3.2所示。</p><table><thead><tr><th>帧头</th><th>数据长度</th><th>指令</th><th>参数</th></tr></thead><tbody><tr><td>0x550x55</td><td>0x08</td><td>0x03</td><td>0x01  0xE8 0x03 0x01 0xD0 0x07</td></tr></tbody></table><p>比如控制2和9号舵机800ms内2号转到1200的位置，9号转到2300的位置，如表3.3所示。</p><table><thead><tr><th>帧头</th><th>数据长度</th><th>指令</th><th>参数</th></tr></thead><tbody><tr><td>0x550x55</td><td>0x0B</td><td>0x03</td><td>0x02  0x20 0x03 0x02 0xB0 0x04 0x09 0xFC 0x08</td></tr></tbody></table><p><strong>采用树莓派的ttyAMA0的串口，但此设备默认给了蓝牙，所以需要改变映射规则，具体操作，请百度。</strong></p><p>将 串口通信 文件夹重命名为serial。在serial文件夹中make。会生成libserial.so静态链接库，里面实现了具体的串口通信的方法，源码中有注释。</p><p>关于卷积运算分类图像请看我的另一篇文章：<a href="https://codezhou.club/2020/04/07/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E5%9B%BE%E7%89%87/">https://codezhou.club/2020/04/07/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB%E5%9B%BE%E7%89%87/</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 智能控制 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 机器视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升降式双旋翼飞行器</title>
      <link href="/2019/09/07/shuang-xuan-yi-fei-xing-qi/"/>
      <url>/2019/09/07/shuang-xuan-yi-fei-xing-qi/</url>
      
        <content type="html"><![CDATA[<p>2018年湖南省大学生电子设计竞赛设计——</p><h1 id="升降式双旋翼飞行器"><a href="#升降式双旋翼飞行器" class="headerlink" title="升降式双旋翼飞行器"></a><strong>升降式双旋翼飞行器</strong></h1><h2 id="1、赛题简介"><a href="#1、赛题简介" class="headerlink" title="1、赛题简介"></a>1、赛题简介</h2><h3 id="1-1、赛题任务"><a href="#1-1、赛题任务" class="headerlink" title="1.1、赛题任务"></a>1.1、赛题任务</h3><p>设计并制作一个沿竖杆升降的双旋翼飞行器及其控制系统。竖杆采用φ 12mm的圆钢，外套φ 17mm不锈钢管，长(1.4~1.7)m, 下端固定在底座上，杆上分别标有明显的A、B、C、D点标记，其中: A点距底面30cm, B点距底面70cm, C点距底面100cm，D点距底面130cm，且CD段有cm间隔的标记，如图1所示。双旋翼飞行器由根横板 和安装在横板两端的直流电机、螺旋浆组成，横板长度为50cm，中心最宽处宽度为10cm，两直流电机轴间距离为40cm,且横板中部有一个圆孔( φ20)。竖杆穿过横板中部的圆孔，能使横板沿竖杆自由地上下移动，如图2所示。控制系统通过控制两个螺旋浆的转速实现双旋翼飞行器起飞、降落以及飞行过程中的高度控制。在飞行器上有两个LED灯指示飞行器的状态。其中白色发光二极管为1#指示灯，红色发光二极管为2#指示灯。横板上离中心5cm处需要安装- - 个悬挂法码的小钩。</p><h3 id="1-2、基本要求"><a href="#1-2、基本要求" class="headerlink" title="1.2、基本要求"></a>1.2、基本要求</h3><p>当飞行器静止地停在底面时，键启动控制系统， 分别完成以下飞行过程:</p><p>(1)在15秒内，飞行器由地面上升且高度超过A点3秒以上，再平稳地降落回地面:</p><p>(2)在 20秒内，飞行器由地面上升并悬停在CD段维持3秒以上，再平稳地降落回地面:</p><p>(3) 在30秒内，飞行器由地面上升并悬停在AB段维持3秒，再上升并悬停在CD段维持3秒，再平稳地降落回地面:在此过程中，飞行器悬停在AB段时亮1“灯，在CD段悬停时亮2*灯，其它不亮灯。</p><p> (4) 在30秒内，飞行器由地面上升并悬停在CD段内的指定高度(X)5秒以上，且高度误差不超过Scm (以上下波动中心为准)、上下波动范围不超过5cm, 达到要求时同时亮1”、2*灯;</p><p>(5) 将控制系统、电池等全部安装在横板上，完成基本部分所有要求，且飞行器不出现螺旋状态。</p><h3 id="1-3、发挥部分"><a href="#1-3、发挥部分" class="headerlink" title="1.3、发挥部分"></a>1.3、发挥部分</h3><p>控制系统、电池等全部安装在横板上的条件下:</p><p>(1) 飞行器由地面上升并悬停在CD段内的指定高度(X) 5秒以上时，人为将飞行器拉到BC段，飞行器能够自动返回原先的高度;</p><p>(2)在基本部分(4) 的基础上，进一步提高控制精度， 实现飞行器高度误差不超过3cm、上下波动范围不超过3cm,误差及波动范围越小越好;</p><p> (3)在完成发挥部分(2) 的基础上，实现飞行器高度的增量控制，即:通过按步进值键X)，使飞行器上升Xcm、 或按另一个键使飞行器下降Xcm, 误差、波动范围要求同发挥部分(2)</p><p>(4)在飞行器中间小钩上加挂10克以上重物，完成发挥部分(3)</p><p>(5)自由发挥(仅限于更复杂的飞行路径和提高定位精度)</p><h2 id="2、原理论证"><a href="#2、原理论证" class="headerlink" title="2、原理论证"></a>2、原理论证</h2><blockquote><p>PID 控制器以各种形式使用超过了 1 世纪，广泛应用在机械设备、气动设备 和电子设备.在工业应用中PID及其衍生算法是应用最广泛的算法之一，是当之无愧的万能算法。</p></blockquote><p>PID 实指“比例 proportional”、“积分 integral”、“微分 derivative”，这三项构 成 PID 基本要素。每一项完成不同任务，对系统功能产生不同的影响。它的结构简单，参数易 于调整，是控制系统中经常采用的控制算法。</p><p>**u(t)**为控制器输出的控制量；（输出）</p><p>**e(t)**为偏差信号，它等于给定量与输出量之差；（输入）</p><p><strong>KP</strong> 为比例系数；（对应参数 P）</p><p><strong>TI</strong> 为积分时间常数；（对应参数I）</p><p><strong>TD</strong> 为微分时间常数。(对应参数 D) </p><p>数字 PID 控制算法通常分为位置式 PID 控制算法和增量式 PID 控制算法。  </p><p><strong>位置式 PID 算法 :</strong></p><p> e(k): 用户设定的值（目标值） -  控制对象的当前的状态值 </p><p>比例P :    e(k)</p><p>积分I :   ∑e(i)     误差的累加</p><p>微分D :  e(k) - e(k-1)  这次误差-上次误差</p><p>也就是位置式PID是当前系统的实际位置，与你想要达到的预期位置的偏差，进行PID控制</p><p>因为有误差积分 ∑e(i)，一直累加，也就是当前的输出u(k)与过去的所有状态都有关系，用到了误差的累加值；（误差e会有误差累加），输出的u(k)对应的是执行机构的实际位置，，一旦控制输出出错(控制对象的当前的状态值出现问题 )，u(k)的大幅变化会引起系统的大幅变化</p><p>并且位置式PID在积分项达到饱和时,误差仍然会在积分作用下继续累积，一旦误差开始反向变化，系统需要一定时间从饱和区退出，所以在u(k)达到最大和最小时，要停止积分作用，并且要有积分限幅和输出限幅。</p><p><strong>增量式PID：</strong></p><p>比例P :    e(k)-e(k-1)   这次误差-上次误差</p><p>积分I :   e(i)     误差   </p><p>微分D :  e(k) - 2e(k-1)+e(k-2)   这次误差-2*上次误差+上上次误差</p><p> 增量式PID根据公式可以很好地看出，一旦确定了 KP、TI  、TD，只要使用前后三次测量值的偏差， 即可由公式求出控制增量</p><p>而得出的控制量▲u(k)对应的是近几次位置误差的增量，而不是对应与实际位置的偏差     没有误差累加</p><p>也就是说，增量式PID中不需要累加。控制增量Δu(k)的确定仅与最近3次的采样值有关，容易通过加权处理获得比较好的控制效果，并且在系统发生问题时，增量式不会严重影响系统的工作</p><p><strong>总结：增量型 PID，是对位置型 PID 取增量，这时控制器输出的是相邻两次采样时刻所计算的位置值</strong><br><strong>之差，得到的结果是增量，即在上一次的控制量的基础上需要增加（负值意味减少）控制量。</strong></p><p><code>***增量式与位置式区别：***</code><br>1增量式算法不需要做累加，控制量增量的确定仅与最近几次偏差采样值有关，计算误差对控制 量计算的影响较小。而位置式算法要用到过去偏差的累加值，容易产生较大的累加误差。 </p><p>2增量式算法得出的是控制量的增量，例如在阀门控制中，只输出阀门开度的变化部分，误动作 影响小，必要时还可通过逻辑判断限制或禁止本次输出，不会严重影响系统的工作。 而位置式的输出直接对应对象的输出，因此对系统影响较大。</p><p>3增量式PID控制输出的是控制量增量，并无积分作用，因此该方法适用于执行机构带积分部件的对象，如步进电机等，而位置式PID适用于执行机构不带积分部件的对象，如电液伺服阀。</p><p>4在进行PID控制时，位置式PID需要有积分限幅和输出限幅，而增量式PID只需输出限幅</p><p>位置式PID优缺点：<br>优点：<br>①位置式PID是一种非递推式算法，可直接控制执行机构（如平衡小车），u(k)的值和执行机构的实际位置（如小车当前角度）是一一对应的，因此在执行机构不带积分部件的对象中可以很好应用</p><p>缺点：<br>①每次输出均与过去的状态有关，计算时要对e(k)进行累加，运算工作量大。</p><p>增量式PID优缺点：<br>优点：<br>①误动作时影响小，必要时可用逻辑判断的方法去掉出错数据。<br>②手动/自动切换时冲击小，便于实现无扰动切换。当计算机故障时，仍能保持原值。<br>③算式中不需要累加。控制增量Δu(k)的确定仅与最近3次的采样值有关。</p><p>缺点：<br>①积分截断效应大，有稳态误差；</p><p>②溢出的影响大。有的被控对象用增量式则不太好；</p><p>PID算法C语言实现</p><p>首先，定义一个结构变量，用以存放PID运算中所需要的数据。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> _pid<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">float</span> Set<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//定义设定值</span>    <span class="token keyword">float</span> Actual<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//定义实际值</span>    <span class="token keyword">float</span> Kp<span class="token punctuation">,</span>Ki<span class="token punctuation">,</span>Kd<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//定义比例、积分、微分系数</span>    <span class="token keyword">float</span> err<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//定义偏差</span>    <span class="token keyword">float</span> err_last<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//定义上一个偏差</span>    <span class="token keyword">float</span> Sum_err<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//定义偏差之和</span>    <span class="token keyword">float</span> Proportion<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//定义输出</span>    <span class="token keyword">float</span> Pout<span class="token punctuation">,</span>Iout<span class="token punctuation">,</span>Dout<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//定义个分量输出</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>PID<span class="token punctuation">;</span></code></pre><p>其次，初始化任一PID结构体，并为其动态申请内存。</p><pre class=" language-C"><code class="language-C">PID *PID_Init(float S, float Kp, float Ki, float Kd)&#123;    PID *pid_x = malloc(sizeof(PID));    pid_x->Set = S;    pid_x->Kp = Kp;    pid_x->Ki = Ki;    pid_x->Kd = Kd;    pid_x->err_last = 0;    pid_x->Sum_err = 0;    pid_x->Proportion = 0;    pid_x->Pout = 0;    pid_x->Iout = 0;    pid_x->Dout = 0;    return pid_x;&#125;</code></pre><p>在PID运算过程；</p><pre class=" language-C"><code class="language-C">void PID_Count(PID *pid_x, float Act)&#123;    pid_x->Actual = Act; //更新实际值    pid_x->err_last = pid_x->err;   //更新上次偏差    pid_x->err = pid_x->Set - pid_x->Actual; //更新当前偏差    pid_x->Pout = pid_x->Kp * pid_x->err; //比例输出    pid_x->Sum_err += pid_x->err; //误差总和       pid_x->Iout = (pid_x->Ki) * (pid_x->Sum_err);   //积分输出    pid_x->Dout = (pid_x->Kd) * (pid_x->err - pid_x->err_last); //微分输出    pid_x->Proportion = pid_x->Pout + pid_x->Iout + pid_x->Dout;//总输出&#125;</code></pre><p>更改PID参数</p><pre class=" language-C"><code class="language-C">void PID_Set_K(PID *pid_x, float Kp, float Ki, float Kd) &#123;    pid_x->Kp = Kp;    pid_x->Ki = Ki;    pid_x->Kd = Kd;&#125;</code></pre><h2 id="3、硬件设计"><a href="#3、硬件设计" class="headerlink" title="3、硬件设计"></a>3、硬件设计</h2><p>1·主控制器件的论证与选择</p><p>方案一：采用传统的51系列单片机</p><p>传统的51单片机为8位机，价格便宜，控制简单，但是运算速度慢，片内资源少，存储容量小，难以存储大体积的程序和实现快速精准的反应控制，并且受时钟限制，计时精度不高，外形体积大增加了系统的控制难度。</p><p>方案二：采用32位的ARM微控制器</p><p>STM32F103C8T6是一款基于ARM Cortex-M 内核STM32系列的32位的微控制器，程序存储器容量是64KB，时钟频率高达72MHZ。</p><p>本系统的MCU用于电机控制以及三维角度传感器的信号的采集和处理，对MCU的数据处理和计算要求较高，通过比较，选择方案二。</p><p>2·飞行姿态控制的论证与选择</p><p>采集模块选择：</p><p>方案一：采用MPU-6050模块</p><p>MPU-6050六轴模块采用高精度的陀螺仪加速计MPU6050，内部集成了姿态解算器，配合动态卡尔曼滤波算法，能够在动态环境下准确输出模块的当前姿态，姿态测量精度0.01度，稳定性极高。</p><p>方案二：采用ADXL345倾角传感器</p><p>ADXL345是超低功耗3轴加速度计，分辨率高（13位），数字输出数据为16位二进制补码格式，可通过SPI或I2C数字接口访问。</p><p>综合以上两种方案，选择方案一。</p><p>3·高度采集模块的论证与选择</p><p>方案一：采用的US-100 超声波测距模块可实现 2cm~4.5m 的非接触测距功能，自带温度传感器对测距结果进行校正，同时具有 GPIO，串口等多种通信方式，工作稳定可靠。</p><p>方案二：采用MS5611气压传感器，大气压是随高度变化而变化，通过大气压的变化就能转换成高度变化。</p><p>方案三：采用激光测距。测量距离远，测量精度高，抗干扰能力强，但体积较大，重量较重，且价格较贵。</p><p>考虑到对元器件的熟悉程度，元件的价格以及程序的编写，选择方案一。</p><p>4·遥控器模块的论证与选择</p><p>方案一：采用蓝牙作为遥控器。蓝牙是一种支持设备短距离通信（最大传输距离100米）的无线电技术。可做到10米左右的准确控制，可以不对准。</p><p>方案二：采用红外作为遥控器。红外传输速度快，但传输距离为1~2米，须对准，为单对单传输。</p><p>综合以上两种方案，考虑到准确控制飞行器的飞行，选择方案一。</p><p>5.电机驱动模块</p><p>方案一：298N驱动模块。采用L298N控制芯片。通过单片机改变输入到使能端的电平来控制电机的转速。但飞行器飞行时电机达到的电流远远超过L298N模块所能承受的电流。</p><p>方案二：空模无刷马达电子调速器（ESC）。具有强大的耐流能力。具备出色的马达兼容性和很高的驱动效率。最高转速可以达到210000RPM（2极马达），70000 RPM（2极马达），35000（12极马达）.具有普通启动，柔和启动，超柔和启动三种模式，兼容固定飞机及直升机。可设定油门行程，兼容各种遥控器。具备输入电压异常保护，电池低压保护，油门信号丢失保护等多种保护功能。</p><p>综合以上两种方案，选择方案二。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/zhu.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/yao.png"></h2><h2 id="4、软件设计"><a href="#4、软件设计" class="headerlink" title="4、软件设计"></a>4、软件设计</h2><p>完整代码请访问Github:<a href="https://github.com/Zwyywz/Electronic-design">https://github.com/Zwyywz/Electronic-design</a></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210308211127050.png"></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210308211152974.png"></p><h2 id="5、测试验收"><a href="#5、测试验收" class="headerlink" title="5、测试验收"></a>5、测试验收</h2><p>基础部分：</p><p>（1） 测试基本部分第一项，飞行器能达到A点3秒以上，然后平稳降落到地面，整个过程在15秒以内。说明飞行器能通过PID运算达到指定高度，而且且耗时短。</p><p>（2） 测试基本部分第二项，飞行器能达到CD段悬停3秒以上，然后平稳降落到地面，整个过程耗时18秒。说明飞行器能通过PID运算达到指定高度，并且能维持在某个高度，耗时不是很大。</p><p>（3） 测试基本部分第三项，飞行器能达到AB段悬停3秒以上，再上升到CD段悬停3秒，再平稳落地。在此过程中，在AB段悬停时黄色LED1#灯亮，在CD段悬停时红色LED2#灯亮。但整个过程耗时35秒，超出了要求。主要原因为PID运算输出的电机油门可能太小，导致上升缓慢。.</p><p>（4） 测试基本部分第四项，飞行器达到能CD段的指定高度5秒以上，但是误差超过5cm，上下波动范围不超过5cm,达到要求的同时红灯，黄灯一起亮，主要是因为PID运算的积分作用太大，从而使其超调。</p><p>（5） 将控制系统，电池全部安装在横板上，完成上述操作后，双旋翼出现自旋，主要原因没有用舵机来进行对飞行姿态进行调整，从而出现自旋。</p><p>发挥部分：</p><p>（1） 发挥部分第一项，飞行器能够达到CD段内的100cm处，并且悬停5秒。但稳定需要一定时间，人为拉到BC段内能较快恢复到原来的位置。由此可以分析PID的调节作用还是有的，但开始做PID运算时有点超调，导致悬停稳定时的时间较长。</p><p>（2） 发挥部分第二项，在基础部分第四项的基础上，精度的增加还是完成不了。由此可知PID参数的选定还不够合理。</p><p>（3） 发挥部分第三项，在完成基础部分第二项的基础上，按下步进键，高度增加了20cm，5秒后平稳降落。基本上完成要求。</p><p>（4） 发挥部分第四项，在飞行器上挂上30g的砝码，能完成发挥部分第三项。由此可以得知通过陀螺仪测得Z轴的角度作为PID的反馈，调整两个电机的转速，从而使飞行器达到平衡并且完成相应动作。</p><p>（5） 发挥部分第五项为自由发挥，飞行器分别升到A点，B点，C点，然后降到50cm处，然后平缓降落，每个点悬停的时间均为五秒。</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 智能控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派搭建 【优雅の博客】</title>
      <link href="/2019/09/07/shu-mei-pai-da-jian-ge-ren-bo-ke/"/>
      <url>/2019/09/07/shu-mei-pai-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派搭建-【优雅の博客】"><a href="#树莓派搭建-【优雅の博客】" class="headerlink" title="树莓派搭建 【优雅の博客】"></a>树莓派搭建 【优雅の博客】</h1><h2 id="一、安装基本环境"><a href="#一、安装基本环境" class="headerlink" title="一、安装基本环境"></a>一、安装基本环境</h2><h3 id="1-1-安装树莓派系统（这里推荐Raspberry）"><a href="#1-1-安装树莓派系统（这里推荐Raspberry）" class="headerlink" title="1.1 安装树莓派系统（这里推荐Raspberry）"></a>1.1 安装树莓派系统（这里推荐Raspberry）</h3><p>官网地址：<a href="https://www.raspberrypi.org/software/">https://www.raspberrypi.org/software/</a></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/2.png"></p><p>新手推荐这个带桌面的版本。</p><p>由于某些众所周知的原因，如果不能科学上网，那么下载速度是这样的：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/3.png"></p><p>这里推荐几个国内下载源：</p><ul><li>TUNA 镜像站（位于北京）：<a href="https://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os-images/">https://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os-images/</a></li><li>SJTUG 镜像站（位于上海）：<a href="https://mirrors.sjtug.sjtu.edu.cn/raspberry-pi-os-images/">https://mirrors.sjtug.sjtu.edu.cn/raspberry-pi-os-images/</a></li></ul><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/4.png"></p><p>写盘工具有很多，这里推荐<a href="https://www.balena.io/etcher/">Etcher</a>,比较靠谱。target一定要选择SD卡，千万别选错！！！</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/6.png"></p><p>如果想采用ssh连接树莓派，还需在写制作好的SD卡（<strong>即写盘完成后电脑上会出现的boot分区，如果没有，拔下读卡器重插一下</strong>）中加入两个文件，一个是空白的ssh文件（即新建文本文档，将文件名改为ssh，<strong>去掉后缀名</strong>，<strong>去掉后缀名</strong>，<strong>去掉后缀名</strong>），再有就是wifi配置文件，文件名为wpa_supplicant.conf。内容如下：</p><pre><code>country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;    ssid=&quot;zwy&quot;          psk=&quot;12345678&quot;    priority=5&#125;network=&#123;    ssid=&quot;YiyaYiya&quot;    psk=&quot;lsluhiiin6103&quot;    priority=4&#125;</code></pre><p>ssid:wifi名称</p><p>psk:wifi密码</p><p>priority:连接优先级</p><p>然后，将SD卡插回树莓派上就能正常开机了。不过这里有个巨坑。</p><hr><p><em>树莓派4b的typeC口由于设计问题，使用非官方的充电器，很有可能没法开机，故而推荐官方充电器，如果实在没有，采用手机5V/3A充电器应该也可以（亲测华为mate系列的可以）</em></p><hr><h3 id="1-2-远程连接以及换源"><a href="#1-2-远程连接以及换源" class="headerlink" title="1.2 远程连接以及换源"></a>1.2 远程连接以及换源</h3><p>远程连接工具有很多，我使用的是xshell和xftp。如果是第一次接触linux系统，推荐使用远程桌面工具，不过也需先连接远程终端，安装xrdp工具，只需在命令行输入：</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install xrdp  </code></pre><p>就可以愉快是使用远程桌面了。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/7.png"></p><p>输入默认账号：pi  默认密码：raspberry</p><p>连接后，更改配置，输入：</p><pre class=" language-shell"><code class="language-shell">sudo raspi-config</code></pre><p>选择第一项，更改密码。</p><p>基本配置完成后，开始换源：</p><p>第一步，先备份源文件</p><pre class=" language-sh"><code class="language-sh">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo cp /etc/apt/sources.list.d/raspi.list  etc/apt/sources.list.d/raspi.list.bak</code></pre><p>第二步，编辑系统源文件</p><pre class=" language-shell"><code class="language-shell">sudo nano /etc/apt/sources.list</code></pre><p>第三步，将初始的源使用#注释掉，添加如下两行清华的镜像源。</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</code></pre><p>第四步，保存执行如下命令 sudo apt-get update，完成源的更新软件包索引。</p><pre><code>sudo apt-get update&amp;&amp;sudo apt-get upgrade</code></pre><p>第五步，还需要更改系统源</p><pre class=" language-shell"><code class="language-shell">sudo nano /etc/apt/sources.list.d/raspi.list</code></pre><p>用#注释掉原文件内容，用以下内容取代：</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</code></pre><p>更改pip源<br>新建~/.pip/pip.conf文件，写入其地址。阿里云、中科大、豆瓣等都有pip源。</p><pre class=" language-shell"><code class="language-shell">[global]index-url = http://pypi.douban.com/simple/</code></pre><h2 id="二、相关软件配置"><a href="#二、相关软件配置" class="headerlink" title="二、相关软件配置"></a>二、相关软件配置</h2><h3 id="2-1-配置git"><a href="#2-1-配置git" class="headerlink" title="2.1 配置git"></a>2.1 配置git</h3><p>在树莓派终端输入：</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install git</code></pre><p>在树莓派终端输入下列命令修改全局用户名（注意将引号内替换为个人帐号）：</p><pre class=" language-shell"><code class="language-shell">git config --global user.name "你的GitHub/Gitee用户名"git config --global user.email "你的GitHub/Gitee邮箱"</code></pre><p>然后查看是否已经全局修改用户名：</p><pre class=" language-shell"><code class="language-shell">git config --list</code></pre><p>配置完成后如下图：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122174229788.png"></p><h3 id="2-2安装Node-js"><a href="#2-2安装Node-js" class="headerlink" title="2.2安装Node.js"></a>2.2安装Node.js</h3><p>首先查看树莓派的架构，树莓派终端输入命令:</p><pre class=" language-shell"><code class="language-shell">uname -a</code></pre><p>我使用的树莓派4B是基于<code>armv7</code>架构，如图所示：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122174511028.png"></p><p>然后登录<a href="https://nodejs.org/en/download/">Nood.js官网</a>，我们可以看到长期支持版是<code>14.15.4</code>，可自由选择版本，如下命令根据版本变化。</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122174646072.png"></p><p>在树莓派终端输入：</p><pre class=" language-shell"><code class="language-shell">wget https://nodejs.org/dist/v14.15.4/node-v14.15.4-linux-armv7l.tar.xz</code></pre><p>如果出现下载缓慢的问题我们也可以使用国内开源镜像源(某宝源)下载：</p><pre class=" language-shell"><code class="language-shell">wget https://cdn.npm.taobao.org/dist/node/latest-v14.x/node-v14.15.4-linux-armv7l.tar.xz</code></pre><p>解压二进制包，在树莓派下输入如下命令：</p><pre><code>xz -d node-v14.15.4-linux-armv7l.tar.xz &amp;&amp; tar -xavf node-v14.15.4-linux-armv7l.tar</code></pre><p>解压后，将二进制包移动到<code>/usr/local/node</code>下，在终端输入：</p><pre class=" language-shell"><code class="language-shell">sudo mv ./node-v10.0.0-linux-armv7l /usr/local/node</code></pre><p>然后为<code>node</code>和<code>npm</code>建立软连接，在终端输入：</p><pre class=" language-shell"><code class="language-shell">sudo ln -s /usr/local/node/bin/node /usr/bin/nodesudo ln -s /usr/local/node/bin/npm /usr/bin/npm#这类似于Windows中的快捷方式</code></pre><p>我们通过查看<code>node</code>和<code>npm</code>版本的方式来查看是否成功，在终端输入：</p><pre class=" language-shell"><code class="language-shell">node -v && npm -v</code></pre><p>至此我们完成了<code>hexo</code>博客两大准备工作<code>Git</code>和<code>Node.js</code>的配置，我们正式进入安装<code>hexo</code>博客框架。</p><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>由于国内网速问题<code>npm</code>包管理器的速度会较慢，我们利用<code>npm</code>安装<code>cnpm</code>也就是前文提到的某宝源，在终端输入：</p><pre class=" language-shell"><code class="language-shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>同理我们为<code>cnpm</code>建立软连接，在终端输入：</p><pre class=" language-shell"><code class="language-shell">sudo ln -s /usr/local/node/bin/cnpm /usr/bin/cnpm</code></pre><p>安装Hexo博客框架，在终端输入：</p><pre class=" language-shell"><code class="language-shell">cnpm install -g hexo-cli</code></pre><p>等待执行完，我们通过查看<code>hexo</code>版本的方式来查看是否成功，在终端输入：</p><pre class=" language-shell"><code class="language-shell">hexo -v</code></pre><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122175725229.png"></p><h2 id="四、使用Hexo搭建博客"><a href="#四、使用Hexo搭建博客" class="headerlink" title="四、使用Hexo搭建博客"></a>四、使用Hexo搭建博客</h2><p>创建一个目录，作为博客的根目录，名字任取，这里取<code>blog</code>，并进入<code>blog</code>目录，在终端输入:</p><pre><code>sudo mkdir blogcd blog</code></pre><p>初始化<code>Hexo</code>，在终端输入：</p><pre><code>sudo hexo init</code></pre><p>启动<code>Hexo</code>，在终端输入：</p><pre><code>sudo hexo s</code></pre><p>出现如下图提示后：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122180658511.png"></p><p>在浏览器输入：<code>树莓派IP:4000</code></p><p>可以看到我们的博客已经搭建完成了，如下图<code>hexo</code>自动生成了一篇<code>Hello World</code>的文章，文章内简介了<code>hexo</code>的用法，这里不再赘述，请仔细阅读。</p><p><img src="https://cdn.jsdelivr.net/gh/Fengweicui1996/CDN/4bnoodjs/11.png"></p><p>然后我们回到命令行按住<code>Ctrl+C</code>退出。所有文章均以<code>.md</code>格式保存在<code>/source/_posts</code>我们可以在此目录下删除或添加文章。</p><h2 id="五、将本地Hexo博客部署到远端Github"><a href="#五、将本地Hexo博客部署到远端Github" class="headerlink" title="五、将本地Hexo博客部署到远端Github"></a>五、将本地Hexo博客部署到远端Github</h2><p>我们在<code>github</code>上新建一个仓库<code>Create a new repository</code>，注意仓库名字必须为：</p><p> <strong>你的github账户名.github.io</strong></p><p>后面我们将用此名字作为域名访问博客。</p><p>回到树莓派终端，在博客根目录下，这是<code>/blog</code>目录下，在终端输入：</p><pre class=" language-shell"><code class="language-shell">sudo cnpm install --save hexo-deployer-git</code></pre><p>然后我们需要配置博客根目录下的<code>_config.yml</code>文件，在终端输入：</p><pre class=" language-shell"><code class="language-shell">sudo nano _config.yml</code></pre><p>进入<code>_config.yml</code>后到文件末端，如下图<br>将此处修改为:</p><pre class=" language-shell"><code class="language-shell"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/你的账户名/你的账户名.github.io  branch: master  #注意这里的冒号后要加空格</code></pre><p>按<code>Ctrl+X</code>退出，按<code>Y</code>保存<br>然后依次执行下列三条命令</p><pre class=" language-shell"><code class="language-shell">sudo hexo cleansudo hexo gsudo hexo s</code></pre><p>在树莓派本地浏览器输入如下端口查看本地预览: <code>localhost:4000</code></p><p>然后回到终端<code>Ctrl+C</code>退出，在终端输入：</p><pre class=" language-shell"><code class="language-shell">sudo hexo d</code></pre><p>输入自己的<code>github</code>用户名跟密码，即可推送到<code>github</code>，我们可以输入如下域名查看个人博客。</p><pre><code>你的用户名.github.io</code></pre><p>每次写完博客都要重复这几个步骤。</p><pre><code>sudo hexo dsudo hexo clean &amp;&amp; sudo hexo g &amp;&amp; sudo hexo s</code></pre><h2 id="六、Typora-PicGo-Github图床-优雅の博客"><a href="#六、Typora-PicGo-Github图床-优雅の博客" class="headerlink" title="六、Typora+PicGo+Github图床=优雅の博客"></a>六、Typora+PicGo+Github图床=优雅の博客</h2><blockquote><p>Typora 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是<strong>完全免费</strong>的</p><p>Typora 一直是我认为桌面端笔记应用应有的终极形态。用我之前 一篇文章 中的话来说就是，「它的<strong>功能之强大、设计之冷静、体验之美妙、理念之先进</strong>，我认为值得所有笔记应用厂商学习。</p></blockquote><p>首先安装<a href="https://typora.io/#windows">typora</a>:</p><p>下载-&gt;next ….. next-&gt; 完成。:grin:</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122182557137.png"></p><p>下载完成后可以打开偏好设置：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122182654108.png"></p><p>图片-&gt;上传图片；上传服务-&gt;PicGo,然后点击下载PicGo,会跳转到PicGo的官网</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122182912371.png"></p><p>然后点击免费下载，要求版本<code>&gt;=2.2.0</code>且不推荐<code>beta</code>版,安装完成后，如图：</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122183822206.png"></p><p>接下来创建Github仓库；</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122183957578.png"></p><p>仓库名字：任意（如image、Img皆可）</p><p>切记：选择公开（Public）</p><p>接下来：获得Tokens密钥，网址为：<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122184357428.png"></p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122184558027.png"></p><p>然后配置PicGo,图床设置-&gt;GitHub图床</p><p><img src="https://blog-1300216920.cos.ap-nanjing.myqcloud.com/image-20210122194003722.png"></p><p>设置仓库名：<code>个人名称/刚刚新建的仓库</code></p><p>设置分支名：<code>master</code></p><p>设置Token:<code>刚刚获取的Token</code></p><hr><p>一起设置完成后；</p><p>大功告成！！！撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。:happy:</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
